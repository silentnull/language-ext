// <auto-generated/>

using System;
using System.Text;
using System.Linq;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using LanguageExt.TypeClasses;
using LanguageExt.ClassInstances;
using static LanguageExt.Prelude;

namespace LanguageExt
{
    /// <summary>
    /// Async monad transformer for Arr, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class ArrT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Arr<C>> SelectMany< A, B, C>(
            this OptionAsync<Arr<A>> ma,
            Func<A, OptionAsync<Arr<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Arr<A>> Where< A>(this OptionAsync<Arr<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Arr<A>> Do(Arr<A> a) => default(MOptionAsync<Arr<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Arr<B>> Select< A, B>(this OptionAsync<Arr<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<Arr<B>>).ReturnAsync(_ => default(MArr<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<Arr<A>> ma) =>
            default(TransAsyncSync<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Arr<B>> BindT< A, B>(this OptionAsync<Arr<A>> ma, Func<A, Arr<B>> f) =>
            default(TransAsyncSync<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Bind<MOptionAsync<Arr<B>>, OptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Arr<B>> MapT< A, B>(this OptionAsync<Arr<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Map<MOptionAsync<Arr<B>>, OptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<Arr<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<Arr<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<Arr<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<Arr<A>>, OptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Arr<A>> FilterT< A>(this OptionAsync<Arr<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Arr<A>> Do(Arr<A> a) => default(MOptionAsync<Arr<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Arr<A>> PlusT<NUM,  A>(this OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Arr<A>> SubtractT<NUM,  A>(this OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Arr<A>> ProductT<NUM,  A>(this OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Arr<A>> DivideT<NUM,  A>(this OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Arr<A>> AppendT<SEMI,  A>(this OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<Arr<A>> x, OptionAsync<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<Arr<A>> fa) =>
            default(ApplOptionAsync< Arr<A>, Arr<B>>).Apply(
                default(MOptionAsync< Func<Arr<A>, Arr<B>>>).ReturnAsync(
                    Task.FromResult<Func<Arr<A>, Arr<B>>>((Arr<A> a) => 
                        default(ApplArr< A, B>).Apply(
                            default(MArr< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<Arr<A>> fa, OptionAsync<Arr<B>> fb) =>
            default(ApplOptionAsync< Arr<A>, Arr<B>, Arr<C>>).Apply(
                default(MOptionAsync< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Arr<A>, Func<Arr<B>, Arr<C>>>>((Arr<A> a) =>
                        (Arr<B> b) =>
                            default(ApplArr< A, B, C>).Apply(
                                default(MArr< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, Arr<C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, Arr<A>> ma,
            Func<A, EitherAsync<L, Arr<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Arr<A>> Where<L, A>(this EitherAsync<L, Arr<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Arr<A>> Do(Arr<A> a) => default(MEitherAsync<L, Arr<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Arr<B>> Select<L, A, B>(this EitherAsync<L, Arr<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, Arr<B>>).ReturnAsync(_ => default(MArr<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, Arr<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, Arr<A>>, EitherAsync<L, Arr<A>>, MArr<A>, Arr<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, Arr<A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, Arr<A>>, EitherAsync<L, Arr<A>>, MArr<A>, Arr<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Arr<B>> BindT<L, A, B>(this EitherAsync<L, Arr<A>> ma, Func<A, Arr<B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, Arr<A>>, EitherAsync<L, Arr<A>>, MArr<A>, Arr<A>, A>)
                .Bind<MEitherAsync<L, Arr<B>>, EitherAsync<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Arr<B>> MapT<L, A, B>(this EitherAsync<L, Arr<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, Arr<A>>, EitherAsync<L, Arr<A>>, MArr<A>, Arr<A>, A>)
                .Map<MEitherAsync<L, Arr<B>>, EitherAsync<L, Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Arr<A>>, EitherAsync<L, Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, Arr<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Arr<A>>, EitherAsync<L, Arr<A>>, MArr<A>, Arr<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, Arr<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Arr<A>>, EitherAsync<L, Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, Arr<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Arr<A>>, EitherAsync<L, Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, Arr<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, Arr<A>>, EitherAsync<L, Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Arr<A>> FilterT<L, A>(this EitherAsync<L, Arr<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Arr<A>> Do(Arr<A> a) => default(MEitherAsync<L, Arr<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, Arr<A>> PlusT<NUM, L, A>(this EitherAsync<L, Arr<A>> x, EitherAsync<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, Arr<A>> SubtractT<NUM, L, A>(this EitherAsync<L, Arr<A>> x, EitherAsync<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, Arr<A>> ProductT<NUM, L, A>(this EitherAsync<L, Arr<A>> x, EitherAsync<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, Arr<A>> DivideT<NUM, L, A>(this EitherAsync<L, Arr<A>> x, EitherAsync<L, Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, Arr<A>> AppendT<SEMI, L, A>(this EitherAsync<L, Arr<A>> x, EitherAsync<L, Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, Arr<A>> x, EitherAsync<L, Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, Arr<A>> x, EitherAsync<L, Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Arr&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, Arr<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, Arr<A>> fa) =>
            default(ApplEitherAsync<L, Arr<A>, Arr<B>>).Apply(
                default(MEitherAsync<L, Func<Arr<A>, Arr<B>>>).ReturnAsync(
                    Task.FromResult<Func<Arr<A>, Arr<B>>>((Arr<A> a) => 
                        default(ApplArr< A, B>).Apply(
                            default(MArr< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, Arr&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, Arr<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, Arr<A>> fa, EitherAsync<L, Arr<B>> fb) =>
            default(ApplEitherAsync<L, Arr<A>, Arr<B>, Arr<C>>).Apply(
                default(MEitherAsync<L, Func<Arr<A>, Func<Arr<B>, Arr<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Arr<A>, Func<Arr<B>, Arr<C>>>>((Arr<A> a) =>
                        (Arr<B> b) =>
                            default(ApplArr< A, B, C>).Apply(
                                default(MArr< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Arr<C>> SelectMany< A, B, C>(
            this Task<Arr<A>> ma,
            Func<A, Task<Arr<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Arr<A>> Where< A>(this Task<Arr<A>> ma, Func<A, bool> f)
        {
            Task<Arr<A>> Do(Arr<A> a) => default(MTask<Arr<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Arr<B>> Select< A, B>(this Task<Arr<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<Arr<B>>).ReturnAsync(_ => default(MArr<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<Arr<A>> ma) =>
            default(TransAsyncSync<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Arr<B>> BindT< A, B>(this Task<Arr<A>> ma, Func<A, Arr<B>> f) =>
            default(TransAsyncSync<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Bind<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Arr<B>> MapT< A, B>(this Task<Arr<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Map<MTask<Arr<B>>, Task<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<Arr<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<Arr<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<Arr<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<Arr<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<Arr<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<Arr<A>>, Task<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Arr<A>> FilterT< A>(this Task<Arr<A>> ma, Func<A, bool> f)
        {
            Task<Arr<A>> Do(Arr<A> a) => default(MTask<Arr<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Arr<A>> PlusT<NUM,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Arr<A>> SubtractT<NUM,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Arr<A>> ProductT<NUM,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Arr<A>> DivideT<NUM,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Arr<A>> AppendT<SEMI,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<Arr<A>> x, Task<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Arr<A>> fa) =>
            default(ApplTask< Arr<A>, Arr<B>>).Apply(
                default(MTask< Func<Arr<A>, Arr<B>>>).ReturnAsync(
                    Task.FromResult<Func<Arr<A>, Arr<B>>>((Arr<A> a) => 
                        default(ApplArr< A, B>).Apply(
                            default(MArr< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Arr<A>> fa, Task<Arr<B>> fb) =>
            default(ApplTask< Arr<A>, Arr<B>, Arr<C>>).Apply(
                default(MTask< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Arr<A>, Func<Arr<B>, Arr<C>>>>((Arr<A> a) =>
                        (Arr<B> b) =>
                            default(ApplArr< A, B, C>).Apply(
                                default(MArr< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Arr<C>> SelectMany< A, B, C>(
            this TryAsync<Arr<A>> ma,
            Func<A, TryAsync<Arr<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Arr<A>> Where< A>(this TryAsync<Arr<A>> ma, Func<A, bool> f)
        {
            TryAsync<Arr<A>> Do(Arr<A> a) => default(MTryAsync<Arr<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Arr<B>> Select< A, B>(this TryAsync<Arr<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<Arr<B>>).ReturnAsync(_ => default(MArr<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<Arr<A>> ma) =>
            default(TransAsyncSync<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Arr<B>> BindT< A, B>(this TryAsync<Arr<A>> ma, Func<A, Arr<B>> f) =>
            default(TransAsyncSync<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Bind<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Arr<B>> MapT< A, B>(this TryAsync<Arr<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Map<MTryAsync<Arr<B>>, TryAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<Arr<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<Arr<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<Arr<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<Arr<A>>, TryAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Arr<A>> FilterT< A>(this TryAsync<Arr<A>> ma, Func<A, bool> f)
        {
            TryAsync<Arr<A>> Do(Arr<A> a) => default(MTryAsync<Arr<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Arr<A>> PlusT<NUM,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Arr<A>> SubtractT<NUM,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Arr<A>> ProductT<NUM,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Arr<A>> DivideT<NUM,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Arr<A>> AppendT<SEMI,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<Arr<A>> x, TryAsync<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Arr<A>> fa) =>
            default(ApplTryAsync< Arr<A>, Arr<B>>).Apply(
                default(MTryAsync< Func<Arr<A>, Arr<B>>>).ReturnAsync(
                    Task.FromResult<Func<Arr<A>, Arr<B>>>((Arr<A> a) => 
                        default(ApplArr< A, B>).Apply(
                            default(MArr< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Arr<A>> fa, TryAsync<Arr<B>> fb) =>
            default(ApplTryAsync< Arr<A>, Arr<B>, Arr<C>>).Apply(
                default(MTryAsync< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Arr<A>, Func<Arr<B>, Arr<C>>>>((Arr<A> a) =>
                        (Arr<B> b) =>
                            default(ApplArr< A, B, C>).Apply(
                                default(MArr< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Arr<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Arr<A>> ma,
            Func<A, TryOptionAsync<Arr<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MArr<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> Where< A>(this TryOptionAsync<Arr<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Arr<A>> Do(Arr<A> a) => default(MTryOptionAsync<Arr<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> Select< A, B>(this TryOptionAsync<Arr<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<Arr<B>>).ReturnAsync(_ => default(MArr<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<Arr<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;Arr&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<Arr<A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> BindT< A, B>(this TryOptionAsync<Arr<A>> ma, Func<A, Arr<B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Bind<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> MapT< A, B>(this TryOptionAsync<Arr<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Map<MTryOptionAsync<Arr<B>>, TryOptionAsync<Arr<B>>, MArr<B>, Arr<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<Arr<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<Arr<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<Arr<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;Arr&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<Arr<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<Arr<A>>, TryOptionAsync<Arr<A>>, MArr<A>, Arr<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Arr&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> FilterT< A>(this TryOptionAsync<Arr<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Arr<A>> Do(Arr<A> a) => default(MTryOptionAsync<Arr<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> PlusT<NUM,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> SubtractT<NUM,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> ProductT<NUM,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> DivideT<NUM,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Arr<A>> AppendT<SEMI,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<Arr<A>> x, TryOptionAsync<Arr<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Arr<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Arr<A>> fa) =>
            default(ApplTryOptionAsync< Arr<A>, Arr<B>>).Apply(
                default(MTryOptionAsync< Func<Arr<A>, Arr<B>>>).ReturnAsync(
                    Task.FromResult<Func<Arr<A>, Arr<B>>>((Arr<A> a) => 
                        default(ApplArr< A, B>).Apply(
                            default(MArr< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Arr&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;Arr&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Arr&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Arr<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Arr<A>> fa, TryOptionAsync<Arr<B>> fb) =>
            default(ApplTryOptionAsync< Arr<A>, Arr<B>, Arr<C>>).Apply(
                default(MTryOptionAsync< Func<Arr<A>, Func<Arr<B>, Arr<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Arr<A>, Func<Arr<B>, Arr<C>>>>((Arr<A> a) =>
                        (Arr<B> b) =>
                            default(ApplArr< A, B, C>).Apply(
                                default(MArr< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for HashSet, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class HashSetT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<HashSet<C>> SelectMany< A, B, C>(
            this OptionAsync<HashSet<A>> ma,
            Func<A, OptionAsync<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> Where< A>(this OptionAsync<HashSet<A>> ma, Func<A, bool> f)
        {
            OptionAsync<HashSet<A>> Do(HashSet<A> a) => default(MOptionAsync<HashSet<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<HashSet<B>> Select< A, B>(this OptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<HashSet<B>>).ReturnAsync(_ => default(MHashSet<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<HashSet<A>> ma) =>
            default(TransAsyncSync<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<HashSet<B>> BindT< A, B>(this OptionAsync<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            default(TransAsyncSync<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Bind<MOptionAsync<HashSet<B>>, OptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<HashSet<B>> MapT< A, B>(this OptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Map<MOptionAsync<HashSet<B>>, OptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<HashSet<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<HashSet<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<HashSet<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<HashSet<A>>, OptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> FilterT< A>(this OptionAsync<HashSet<A>> ma, Func<A, bool> f)
        {
            OptionAsync<HashSet<A>> Do(HashSet<A> a) => default(MOptionAsync<HashSet<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> PlusT<NUM,  A>(this OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> SubtractT<NUM,  A>(this OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> ProductT<NUM,  A>(this OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> DivideT<NUM,  A>(this OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<HashSet<A>> AppendT<SEMI,  A>(this OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<HashSet<A>> x, OptionAsync<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<HashSet<A>> fa) =>
            default(ApplOptionAsync< HashSet<A>, HashSet<B>>).Apply(
                default(MOptionAsync< Func<HashSet<A>, HashSet<B>>>).ReturnAsync(
                    Task.FromResult<Func<HashSet<A>, HashSet<B>>>((HashSet<A> a) => 
                        default(ApplHashSet< A, B>).Apply(
                            default(MHashSet< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<HashSet<A>> fa, OptionAsync<HashSet<B>> fb) =>
            default(ApplOptionAsync< HashSet<A>, HashSet<B>, HashSet<C>>).Apply(
                default(MOptionAsync< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>).ReturnAsync(
                    Task.FromResult<Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>((HashSet<A> a) =>
                        (HashSet<B> b) =>
                            default(ApplHashSet< A, B, C>).Apply(
                                default(MHashSet< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, HashSet<C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, HashSet<A>> ma,
            Func<A, EitherAsync<L, HashSet<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, HashSet<A>> Where<L, A>(this EitherAsync<L, HashSet<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, HashSet<A>> Do(HashSet<A> a) => default(MEitherAsync<L, HashSet<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, HashSet<B>> Select<L, A, B>(this EitherAsync<L, HashSet<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, HashSet<B>>).ReturnAsync(_ => default(MHashSet<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, HashSet<A>>, EitherAsync<L, HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, HashSet<A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, HashSet<A>>, EitherAsync<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, HashSet<B>> BindT<L, A, B>(this EitherAsync<L, HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, HashSet<A>>, EitherAsync<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Bind<MEitherAsync<L, HashSet<B>>, EitherAsync<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, HashSet<B>> MapT<L, A, B>(this EitherAsync<L, HashSet<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, HashSet<A>>, EitherAsync<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Map<MEitherAsync<L, HashSet<B>>, EitherAsync<L, HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, HashSet<A>>, EitherAsync<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, HashSet<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, HashSet<A>>, EitherAsync<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, HashSet<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, HashSet<A>>, EitherAsync<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, HashSet<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, HashSet<A>>, EitherAsync<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, HashSet<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, HashSet<A>>, EitherAsync<L, HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, HashSet<A>> FilterT<L, A>(this EitherAsync<L, HashSet<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, HashSet<A>> Do(HashSet<A> a) => default(MEitherAsync<L, HashSet<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, HashSet<A>> PlusT<NUM, L, A>(this EitherAsync<L, HashSet<A>> x, EitherAsync<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, HashSet<A>> SubtractT<NUM, L, A>(this EitherAsync<L, HashSet<A>> x, EitherAsync<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, HashSet<A>> ProductT<NUM, L, A>(this EitherAsync<L, HashSet<A>> x, EitherAsync<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, HashSet<A>> DivideT<NUM, L, A>(this EitherAsync<L, HashSet<A>> x, EitherAsync<L, HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, HashSet<A>> AppendT<SEMI, L, A>(this EitherAsync<L, HashSet<A>> x, EitherAsync<L, HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, HashSet<A>> x, EitherAsync<L, HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, HashSet<A>> x, EitherAsync<L, HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, HashSet<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, HashSet<A>> fa) =>
            default(ApplEitherAsync<L, HashSet<A>, HashSet<B>>).Apply(
                default(MEitherAsync<L, Func<HashSet<A>, HashSet<B>>>).ReturnAsync(
                    Task.FromResult<Func<HashSet<A>, HashSet<B>>>((HashSet<A> a) => 
                        default(ApplHashSet< A, B>).Apply(
                            default(MHashSet< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, HashSet<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, HashSet<A>> fa, EitherAsync<L, HashSet<B>> fb) =>
            default(ApplEitherAsync<L, HashSet<A>, HashSet<B>, HashSet<C>>).Apply(
                default(MEitherAsync<L, Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>).ReturnAsync(
                    Task.FromResult<Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>((HashSet<A> a) =>
                        (HashSet<B> b) =>
                            default(ApplHashSet< A, B, C>).Apply(
                                default(MHashSet< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<HashSet<C>> SelectMany< A, B, C>(
            this Task<HashSet<A>> ma,
            Func<A, Task<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<HashSet<A>> Where< A>(this Task<HashSet<A>> ma, Func<A, bool> f)
        {
            Task<HashSet<A>> Do(HashSet<A> a) => default(MTask<HashSet<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<HashSet<B>> Select< A, B>(this Task<HashSet<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<HashSet<B>>).ReturnAsync(_ => default(MHashSet<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<HashSet<A>> ma) =>
            default(TransAsyncSync<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<HashSet<B>> BindT< A, B>(this Task<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            default(TransAsyncSync<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Bind<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<HashSet<B>> MapT< A, B>(this Task<HashSet<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Map<MTask<HashSet<B>>, Task<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<HashSet<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<HashSet<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<HashSet<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<HashSet<A>>, Task<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<HashSet<A>> FilterT< A>(this Task<HashSet<A>> ma, Func<A, bool> f)
        {
            Task<HashSet<A>> Do(HashSet<A> a) => default(MTask<HashSet<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<HashSet<A>> PlusT<NUM,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<HashSet<A>> SubtractT<NUM,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<HashSet<A>> ProductT<NUM,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<HashSet<A>> DivideT<NUM,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<HashSet<A>> AppendT<SEMI,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<HashSet<A>> x, Task<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, Task<HashSet<A>> fa) =>
            default(ApplTask< HashSet<A>, HashSet<B>>).Apply(
                default(MTask< Func<HashSet<A>, HashSet<B>>>).ReturnAsync(
                    Task.FromResult<Func<HashSet<A>, HashSet<B>>>((HashSet<A> a) => 
                        default(ApplHashSet< A, B>).Apply(
                            default(MHashSet< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<HashSet<A>> fa, Task<HashSet<B>> fb) =>
            default(ApplTask< HashSet<A>, HashSet<B>, HashSet<C>>).Apply(
                default(MTask< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>).ReturnAsync(
                    Task.FromResult<Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>((HashSet<A> a) =>
                        (HashSet<B> b) =>
                            default(ApplHashSet< A, B, C>).Apply(
                                default(MHashSet< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<HashSet<C>> SelectMany< A, B, C>(
            this TryAsync<HashSet<A>> ma,
            Func<A, TryAsync<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<HashSet<A>> Where< A>(this TryAsync<HashSet<A>> ma, Func<A, bool> f)
        {
            TryAsync<HashSet<A>> Do(HashSet<A> a) => default(MTryAsync<HashSet<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<HashSet<B>> Select< A, B>(this TryAsync<HashSet<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<HashSet<B>>).ReturnAsync(_ => default(MHashSet<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<HashSet<A>> ma) =>
            default(TransAsyncSync<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<HashSet<B>> BindT< A, B>(this TryAsync<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            default(TransAsyncSync<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Bind<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<HashSet<B>> MapT< A, B>(this TryAsync<HashSet<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Map<MTryAsync<HashSet<B>>, TryAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<HashSet<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<HashSet<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<HashSet<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<HashSet<A>>, TryAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<HashSet<A>> FilterT< A>(this TryAsync<HashSet<A>> ma, Func<A, bool> f)
        {
            TryAsync<HashSet<A>> Do(HashSet<A> a) => default(MTryAsync<HashSet<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<HashSet<A>> PlusT<NUM,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<HashSet<A>> SubtractT<NUM,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<HashSet<A>> ProductT<NUM,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<HashSet<A>> DivideT<NUM,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<HashSet<A>> AppendT<SEMI,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<HashSet<A>> x, TryAsync<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<HashSet<A>> fa) =>
            default(ApplTryAsync< HashSet<A>, HashSet<B>>).Apply(
                default(MTryAsync< Func<HashSet<A>, HashSet<B>>>).ReturnAsync(
                    Task.FromResult<Func<HashSet<A>, HashSet<B>>>((HashSet<A> a) => 
                        default(ApplHashSet< A, B>).Apply(
                            default(MHashSet< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<HashSet<A>> fa, TryAsync<HashSet<B>> fb) =>
            default(ApplTryAsync< HashSet<A>, HashSet<B>, HashSet<C>>).Apply(
                default(MTryAsync< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>).ReturnAsync(
                    Task.FromResult<Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>((HashSet<A> a) =>
                        (HashSet<B> b) =>
                            default(ApplHashSet< A, B, C>).Apply(
                                default(MHashSet< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<HashSet<C>> SelectMany< A, B, C>(
            this TryOptionAsync<HashSet<A>> ma,
            Func<A, TryOptionAsync<HashSet<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MHashSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> Where< A>(this TryOptionAsync<HashSet<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<HashSet<A>> Do(HashSet<A> a) => default(MTryOptionAsync<HashSet<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> Select< A, B>(this TryOptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<HashSet<B>>).ReturnAsync(_ => default(MHashSet<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<HashSet<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<HashSet<A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> BindT< A, B>(this TryOptionAsync<HashSet<A>> ma, Func<A, HashSet<B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Bind<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> MapT< A, B>(this TryOptionAsync<HashSet<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Map<MTryOptionAsync<HashSet<B>>, TryOptionAsync<HashSet<B>>, MHashSet<B>, HashSet<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<HashSet<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<HashSet<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<HashSet<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<HashSet<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<HashSet<A>>, TryOptionAsync<HashSet<A>>, MHashSet<A>, HashSet<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> FilterT< A>(this TryOptionAsync<HashSet<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<HashSet<A>> Do(HashSet<A> a) => default(MTryOptionAsync<HashSet<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> PlusT<NUM,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> SubtractT<NUM,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> ProductT<NUM,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> DivideT<NUM,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<A>> AppendT<SEMI,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<HashSet<A>> x, TryOptionAsync<HashSet<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<HashSet<A>> fa) =>
            default(ApplTryOptionAsync< HashSet<A>, HashSet<B>>).Apply(
                default(MTryOptionAsync< Func<HashSet<A>, HashSet<B>>>).ReturnAsync(
                    Task.FromResult<Func<HashSet<A>, HashSet<B>>>((HashSet<A> a) => 
                        default(ApplHashSet< A, B>).Apply(
                            default(MHashSet< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;HashSet&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;HashSet&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<HashSet<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<HashSet<A>> fa, TryOptionAsync<HashSet<B>> fb) =>
            default(ApplTryOptionAsync< HashSet<A>, HashSet<B>, HashSet<C>>).Apply(
                default(MTryOptionAsync< Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>).ReturnAsync(
                    Task.FromResult<Func<HashSet<A>, Func<HashSet<B>, HashSet<C>>>>((HashSet<A> a) =>
                        (HashSet<B> b) =>
                            default(ApplHashSet< A, B, C>).Apply(
                                default(MHashSet< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for Lst, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class LstT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Lst<C>> SelectMany< A, B, C>(
            this OptionAsync<Lst<A>> ma,
            Func<A, OptionAsync<Lst<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Lst<A>> Where< A>(this OptionAsync<Lst<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Lst<A>> Do(Lst<A> a) => default(MOptionAsync<Lst<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Lst<B>> Select< A, B>(this OptionAsync<Lst<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<Lst<B>>).ReturnAsync(_ => default(MLst<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<Lst<A>> ma) =>
            default(TransAsyncSync<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Lst<B>> BindT< A, B>(this OptionAsync<Lst<A>> ma, Func<A, Lst<B>> f) =>
            default(TransAsyncSync<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Bind<MOptionAsync<Lst<B>>, OptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Lst<B>> MapT< A, B>(this OptionAsync<Lst<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Map<MOptionAsync<Lst<B>>, OptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<Lst<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<Lst<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<Lst<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<Lst<A>>, OptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Lst<A>> FilterT< A>(this OptionAsync<Lst<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Lst<A>> Do(Lst<A> a) => default(MOptionAsync<Lst<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Lst<A>> PlusT<NUM,  A>(this OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Lst<A>> SubtractT<NUM,  A>(this OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Lst<A>> ProductT<NUM,  A>(this OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Lst<A>> DivideT<NUM,  A>(this OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Lst<A>> AppendT<SEMI,  A>(this OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<Lst<A>> x, OptionAsync<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<Lst<A>> fa) =>
            default(ApplOptionAsync< Lst<A>, Lst<B>>).Apply(
                default(MOptionAsync< Func<Lst<A>, Lst<B>>>).ReturnAsync(
                    Task.FromResult<Func<Lst<A>, Lst<B>>>((Lst<A> a) => 
                        default(ApplLst< A, B>).Apply(
                            default(MLst< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<Lst<A>> fa, OptionAsync<Lst<B>> fb) =>
            default(ApplOptionAsync< Lst<A>, Lst<B>, Lst<C>>).Apply(
                default(MOptionAsync< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Lst<A>, Func<Lst<B>, Lst<C>>>>((Lst<A> a) =>
                        (Lst<B> b) =>
                            default(ApplLst< A, B, C>).Apply(
                                default(MLst< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, Lst<C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, Lst<A>> ma,
            Func<A, EitherAsync<L, Lst<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Lst<A>> Where<L, A>(this EitherAsync<L, Lst<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Lst<A>> Do(Lst<A> a) => default(MEitherAsync<L, Lst<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Lst<B>> Select<L, A, B>(this EitherAsync<L, Lst<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, Lst<B>>).ReturnAsync(_ => default(MLst<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, Lst<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, Lst<A>>, EitherAsync<L, Lst<A>>, MLst<A>, Lst<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, Lst<A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, Lst<A>>, EitherAsync<L, Lst<A>>, MLst<A>, Lst<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Lst<B>> BindT<L, A, B>(this EitherAsync<L, Lst<A>> ma, Func<A, Lst<B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, Lst<A>>, EitherAsync<L, Lst<A>>, MLst<A>, Lst<A>, A>)
                .Bind<MEitherAsync<L, Lst<B>>, EitherAsync<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Lst<B>> MapT<L, A, B>(this EitherAsync<L, Lst<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, Lst<A>>, EitherAsync<L, Lst<A>>, MLst<A>, Lst<A>, A>)
                .Map<MEitherAsync<L, Lst<B>>, EitherAsync<L, Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Lst<A>>, EitherAsync<L, Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, Lst<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Lst<A>>, EitherAsync<L, Lst<A>>, MLst<A>, Lst<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, Lst<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Lst<A>>, EitherAsync<L, Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, Lst<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Lst<A>>, EitherAsync<L, Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, Lst<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, Lst<A>>, EitherAsync<L, Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Lst<A>> FilterT<L, A>(this EitherAsync<L, Lst<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Lst<A>> Do(Lst<A> a) => default(MEitherAsync<L, Lst<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, Lst<A>> PlusT<NUM, L, A>(this EitherAsync<L, Lst<A>> x, EitherAsync<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, Lst<A>> SubtractT<NUM, L, A>(this EitherAsync<L, Lst<A>> x, EitherAsync<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, Lst<A>> ProductT<NUM, L, A>(this EitherAsync<L, Lst<A>> x, EitherAsync<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, Lst<A>> DivideT<NUM, L, A>(this EitherAsync<L, Lst<A>> x, EitherAsync<L, Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, Lst<A>> AppendT<SEMI, L, A>(this EitherAsync<L, Lst<A>> x, EitherAsync<L, Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, Lst<A>> x, EitherAsync<L, Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, Lst<A>> x, EitherAsync<L, Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Lst&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, Lst<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, Lst<A>> fa) =>
            default(ApplEitherAsync<L, Lst<A>, Lst<B>>).Apply(
                default(MEitherAsync<L, Func<Lst<A>, Lst<B>>>).ReturnAsync(
                    Task.FromResult<Func<Lst<A>, Lst<B>>>((Lst<A> a) => 
                        default(ApplLst< A, B>).Apply(
                            default(MLst< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, Lst&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, Lst<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, Lst<A>> fa, EitherAsync<L, Lst<B>> fb) =>
            default(ApplEitherAsync<L, Lst<A>, Lst<B>, Lst<C>>).Apply(
                default(MEitherAsync<L, Func<Lst<A>, Func<Lst<B>, Lst<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Lst<A>, Func<Lst<B>, Lst<C>>>>((Lst<A> a) =>
                        (Lst<B> b) =>
                            default(ApplLst< A, B, C>).Apply(
                                default(MLst< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Lst<C>> SelectMany< A, B, C>(
            this Task<Lst<A>> ma,
            Func<A, Task<Lst<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Lst<A>> Where< A>(this Task<Lst<A>> ma, Func<A, bool> f)
        {
            Task<Lst<A>> Do(Lst<A> a) => default(MTask<Lst<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Lst<B>> Select< A, B>(this Task<Lst<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<Lst<B>>).ReturnAsync(_ => default(MLst<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<Lst<A>> ma) =>
            default(TransAsyncSync<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Lst<B>> BindT< A, B>(this Task<Lst<A>> ma, Func<A, Lst<B>> f) =>
            default(TransAsyncSync<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Bind<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Lst<B>> MapT< A, B>(this Task<Lst<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Map<MTask<Lst<B>>, Task<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<Lst<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<Lst<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<Lst<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<Lst<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<Lst<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<Lst<A>>, Task<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Lst<A>> FilterT< A>(this Task<Lst<A>> ma, Func<A, bool> f)
        {
            Task<Lst<A>> Do(Lst<A> a) => default(MTask<Lst<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Lst<A>> PlusT<NUM,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Lst<A>> SubtractT<NUM,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Lst<A>> ProductT<NUM,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Lst<A>> DivideT<NUM,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Lst<A>> AppendT<SEMI,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<Lst<A>> x, Task<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Lst<A>> fa) =>
            default(ApplTask< Lst<A>, Lst<B>>).Apply(
                default(MTask< Func<Lst<A>, Lst<B>>>).ReturnAsync(
                    Task.FromResult<Func<Lst<A>, Lst<B>>>((Lst<A> a) => 
                        default(ApplLst< A, B>).Apply(
                            default(MLst< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Lst<A>> fa, Task<Lst<B>> fb) =>
            default(ApplTask< Lst<A>, Lst<B>, Lst<C>>).Apply(
                default(MTask< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Lst<A>, Func<Lst<B>, Lst<C>>>>((Lst<A> a) =>
                        (Lst<B> b) =>
                            default(ApplLst< A, B, C>).Apply(
                                default(MLst< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Lst<C>> SelectMany< A, B, C>(
            this TryAsync<Lst<A>> ma,
            Func<A, TryAsync<Lst<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Lst<A>> Where< A>(this TryAsync<Lst<A>> ma, Func<A, bool> f)
        {
            TryAsync<Lst<A>> Do(Lst<A> a) => default(MTryAsync<Lst<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Lst<B>> Select< A, B>(this TryAsync<Lst<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<Lst<B>>).ReturnAsync(_ => default(MLst<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<Lst<A>> ma) =>
            default(TransAsyncSync<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Lst<B>> BindT< A, B>(this TryAsync<Lst<A>> ma, Func<A, Lst<B>> f) =>
            default(TransAsyncSync<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Bind<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Lst<B>> MapT< A, B>(this TryAsync<Lst<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Map<MTryAsync<Lst<B>>, TryAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<Lst<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<Lst<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<Lst<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<Lst<A>>, TryAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Lst<A>> FilterT< A>(this TryAsync<Lst<A>> ma, Func<A, bool> f)
        {
            TryAsync<Lst<A>> Do(Lst<A> a) => default(MTryAsync<Lst<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Lst<A>> PlusT<NUM,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Lst<A>> SubtractT<NUM,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Lst<A>> ProductT<NUM,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Lst<A>> DivideT<NUM,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Lst<A>> AppendT<SEMI,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<Lst<A>> x, TryAsync<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Lst<A>> fa) =>
            default(ApplTryAsync< Lst<A>, Lst<B>>).Apply(
                default(MTryAsync< Func<Lst<A>, Lst<B>>>).ReturnAsync(
                    Task.FromResult<Func<Lst<A>, Lst<B>>>((Lst<A> a) => 
                        default(ApplLst< A, B>).Apply(
                            default(MLst< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Lst<A>> fa, TryAsync<Lst<B>> fb) =>
            default(ApplTryAsync< Lst<A>, Lst<B>, Lst<C>>).Apply(
                default(MTryAsync< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Lst<A>, Func<Lst<B>, Lst<C>>>>((Lst<A> a) =>
                        (Lst<B> b) =>
                            default(ApplLst< A, B, C>).Apply(
                                default(MLst< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Lst<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Lst<A>> ma,
            Func<A, TryOptionAsync<Lst<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MLst<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> Where< A>(this TryOptionAsync<Lst<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Lst<A>> Do(Lst<A> a) => default(MTryOptionAsync<Lst<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> Select< A, B>(this TryOptionAsync<Lst<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<Lst<B>>).ReturnAsync(_ => default(MLst<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<Lst<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;Lst&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<Lst<A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> BindT< A, B>(this TryOptionAsync<Lst<A>> ma, Func<A, Lst<B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Bind<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> MapT< A, B>(this TryOptionAsync<Lst<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Map<MTryOptionAsync<Lst<B>>, TryOptionAsync<Lst<B>>, MLst<B>, Lst<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<Lst<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<Lst<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<Lst<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;Lst&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<Lst<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<Lst<A>>, TryOptionAsync<Lst<A>>, MLst<A>, Lst<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Lst&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> FilterT< A>(this TryOptionAsync<Lst<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Lst<A>> Do(Lst<A> a) => default(MTryOptionAsync<Lst<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> PlusT<NUM,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> SubtractT<NUM,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> ProductT<NUM,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> DivideT<NUM,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Lst<A>> AppendT<SEMI,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<Lst<A>> x, TryOptionAsync<Lst<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Lst<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Lst<A>> fa) =>
            default(ApplTryOptionAsync< Lst<A>, Lst<B>>).Apply(
                default(MTryOptionAsync< Func<Lst<A>, Lst<B>>>).ReturnAsync(
                    Task.FromResult<Func<Lst<A>, Lst<B>>>((Lst<A> a) => 
                        default(ApplLst< A, B>).Apply(
                            default(MLst< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Lst&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;Lst&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Lst&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Lst<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Lst<A>> fa, TryOptionAsync<Lst<B>> fb) =>
            default(ApplTryOptionAsync< Lst<A>, Lst<B>, Lst<C>>).Apply(
                default(MTryOptionAsync< Func<Lst<A>, Func<Lst<B>, Lst<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Lst<A>, Func<Lst<B>, Lst<C>>>>((Lst<A> a) =>
                        (Lst<B> b) =>
                            default(ApplLst< A, B, C>).Apply(
                                default(MLst< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for Option, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class OptionT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Option<C>> SelectMany< A, B, C>(
            this OptionAsync<Option<A>> ma,
            Func<A, OptionAsync<Option<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Option<A>> Where< A>(this OptionAsync<Option<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Option<A>> Do(Option<A> a) => default(MOptionAsync<Option<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Option<B>> Select< A, B>(this OptionAsync<Option<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<Option<B>>).ReturnAsync(_ => default(MOption<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<Option<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<Option<A>> ma) =>
            default(TransAsyncSync<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Option<B>> BindT< A, B>(this OptionAsync<Option<A>> ma, Func<A, Option<B>> f) =>
            default(TransAsyncSync<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Bind<MOptionAsync<Option<B>>, OptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Option<B>> MapT< A, B>(this OptionAsync<Option<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Map<MOptionAsync<Option<B>>, OptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<Option<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<Option<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<Option<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<Option<A>>, OptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Option<A>> FilterT< A>(this OptionAsync<Option<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Option<A>> Do(Option<A> a) => default(MOptionAsync<Option<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Option<A>> PlusT<NUM,  A>(this OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Option<A>> SubtractT<NUM,  A>(this OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Option<A>> ProductT<NUM,  A>(this OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Option<A>> DivideT<NUM,  A>(this OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Option<A>> AppendT<SEMI,  A>(this OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<Option<A>> x, OptionAsync<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Option<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<Option<A>> fa) =>
            default(ApplOptionAsync< Option<A>, Option<B>>).Apply(
                default(MOptionAsync< Func<Option<A>, Option<B>>>).ReturnAsync(
                    Task.FromResult<Func<Option<A>, Option<B>>>((Option<A> a) => 
                        default(ApplOption< A, B>).Apply(
                            default(MOption< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<Option<A>> fa, OptionAsync<Option<B>> fb) =>
            default(ApplOptionAsync< Option<A>, Option<B>, Option<C>>).Apply(
                default(MOptionAsync< Func<Option<A>, Func<Option<B>, Option<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Option<A>, Func<Option<B>, Option<C>>>>((Option<A> a) =>
                        (Option<B> b) =>
                            default(ApplOption< A, B, C>).Apply(
                                default(MOption< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, Option<C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, Option<A>> ma,
            Func<A, EitherAsync<L, Option<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Option<A>> Where<L, A>(this EitherAsync<L, Option<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Option<A>> Do(Option<A> a) => default(MEitherAsync<L, Option<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Option<B>> Select<L, A, B>(this EitherAsync<L, Option<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, Option<B>>).ReturnAsync(_ => default(MOption<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, Option<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, Option<A>>, EitherAsync<L, Option<A>>, MOption<A>, Option<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, Option<A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, Option<A>>, EitherAsync<L, Option<A>>, MOption<A>, Option<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Option<B>> BindT<L, A, B>(this EitherAsync<L, Option<A>> ma, Func<A, Option<B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, Option<A>>, EitherAsync<L, Option<A>>, MOption<A>, Option<A>, A>)
                .Bind<MEitherAsync<L, Option<B>>, EitherAsync<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Option<B>> MapT<L, A, B>(this EitherAsync<L, Option<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, Option<A>>, EitherAsync<L, Option<A>>, MOption<A>, Option<A>, A>)
                .Map<MEitherAsync<L, Option<B>>, EitherAsync<L, Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Option<A>>, EitherAsync<L, Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, Option<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Option<A>>, EitherAsync<L, Option<A>>, MOption<A>, Option<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, Option<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Option<A>>, EitherAsync<L, Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, Option<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Option<A>>, EitherAsync<L, Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, Option<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, Option<A>>, EitherAsync<L, Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Option<A>> FilterT<L, A>(this EitherAsync<L, Option<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Option<A>> Do(Option<A> a) => default(MEitherAsync<L, Option<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, Option<A>> PlusT<NUM, L, A>(this EitherAsync<L, Option<A>> x, EitherAsync<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, Option<A>> SubtractT<NUM, L, A>(this EitherAsync<L, Option<A>> x, EitherAsync<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, Option<A>> ProductT<NUM, L, A>(this EitherAsync<L, Option<A>> x, EitherAsync<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, Option<A>> DivideT<NUM, L, A>(this EitherAsync<L, Option<A>> x, EitherAsync<L, Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, Option<A>> AppendT<SEMI, L, A>(this EitherAsync<L, Option<A>> x, EitherAsync<L, Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, Option<A>> x, EitherAsync<L, Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, Option<A>> x, EitherAsync<L, Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Option&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, Option<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, Option<A>> fa) =>
            default(ApplEitherAsync<L, Option<A>, Option<B>>).Apply(
                default(MEitherAsync<L, Func<Option<A>, Option<B>>>).ReturnAsync(
                    Task.FromResult<Func<Option<A>, Option<B>>>((Option<A> a) => 
                        default(ApplOption< A, B>).Apply(
                            default(MOption< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, Option&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, Option<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, Option<A>> fa, EitherAsync<L, Option<B>> fb) =>
            default(ApplEitherAsync<L, Option<A>, Option<B>, Option<C>>).Apply(
                default(MEitherAsync<L, Func<Option<A>, Func<Option<B>, Option<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Option<A>, Func<Option<B>, Option<C>>>>((Option<A> a) =>
                        (Option<B> b) =>
                            default(ApplOption< A, B, C>).Apply(
                                default(MOption< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Option<C>> SelectMany< A, B, C>(
            this Task<Option<A>> ma,
            Func<A, Task<Option<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Option<A>> Where< A>(this Task<Option<A>> ma, Func<A, bool> f)
        {
            Task<Option<A>> Do(Option<A> a) => default(MTask<Option<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Option<B>> Select< A, B>(this Task<Option<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<Option<B>>).ReturnAsync(_ => default(MOption<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<Option<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<Option<A>> ma) =>
            default(TransAsyncSync<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Option<B>> BindT< A, B>(this Task<Option<A>> ma, Func<A, Option<B>> f) =>
            default(TransAsyncSync<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>)
                .Bind<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Option<B>> MapT< A, B>(this Task<Option<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>)
                .Map<MTask<Option<B>>, Task<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<Option<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<Option<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<Option<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<Option<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<Option<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<Option<A>>, Task<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Option<A>> FilterT< A>(this Task<Option<A>> ma, Func<A, bool> f)
        {
            Task<Option<A>> Do(Option<A> a) => default(MTask<Option<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Option<A>> PlusT<NUM,  A>(this Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Option<A>> SubtractT<NUM,  A>(this Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Option<A>> ProductT<NUM,  A>(this Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Option<A>> DivideT<NUM,  A>(this Task<Option<A>> x, Task<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Option<A>> AppendT<SEMI,  A>(this Task<Option<A>> x, Task<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<Option<A>> x, Task<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<Option<A>> x, Task<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Option<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Option<A>> fa) =>
            default(ApplTask< Option<A>, Option<B>>).Apply(
                default(MTask< Func<Option<A>, Option<B>>>).ReturnAsync(
                    Task.FromResult<Func<Option<A>, Option<B>>>((Option<A> a) => 
                        default(ApplOption< A, B>).Apply(
                            default(MOption< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Option<A>> fa, Task<Option<B>> fb) =>
            default(ApplTask< Option<A>, Option<B>, Option<C>>).Apply(
                default(MTask< Func<Option<A>, Func<Option<B>, Option<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Option<A>, Func<Option<B>, Option<C>>>>((Option<A> a) =>
                        (Option<B> b) =>
                            default(ApplOption< A, B, C>).Apply(
                                default(MOption< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Option<C>> SelectMany< A, B, C>(
            this TryAsync<Option<A>> ma,
            Func<A, TryAsync<Option<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Option<A>> Where< A>(this TryAsync<Option<A>> ma, Func<A, bool> f)
        {
            TryAsync<Option<A>> Do(Option<A> a) => default(MTryAsync<Option<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Option<B>> Select< A, B>(this TryAsync<Option<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<Option<B>>).ReturnAsync(_ => default(MOption<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<Option<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<Option<A>> ma) =>
            default(TransAsyncSync<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Option<B>> BindT< A, B>(this TryAsync<Option<A>> ma, Func<A, Option<B>> f) =>
            default(TransAsyncSync<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Bind<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Option<B>> MapT< A, B>(this TryAsync<Option<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Map<MTryAsync<Option<B>>, TryAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<Option<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<Option<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<Option<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<Option<A>>, TryAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Option<A>> FilterT< A>(this TryAsync<Option<A>> ma, Func<A, bool> f)
        {
            TryAsync<Option<A>> Do(Option<A> a) => default(MTryAsync<Option<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Option<A>> PlusT<NUM,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Option<A>> SubtractT<NUM,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Option<A>> ProductT<NUM,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Option<A>> DivideT<NUM,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Option<A>> AppendT<SEMI,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<Option<A>> x, TryAsync<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Option<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Option<A>> fa) =>
            default(ApplTryAsync< Option<A>, Option<B>>).Apply(
                default(MTryAsync< Func<Option<A>, Option<B>>>).ReturnAsync(
                    Task.FromResult<Func<Option<A>, Option<B>>>((Option<A> a) => 
                        default(ApplOption< A, B>).Apply(
                            default(MOption< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Option<A>> fa, TryAsync<Option<B>> fb) =>
            default(ApplTryAsync< Option<A>, Option<B>, Option<C>>).Apply(
                default(MTryAsync< Func<Option<A>, Func<Option<B>, Option<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Option<A>, Func<Option<B>, Option<C>>>>((Option<A> a) =>
                        (Option<B> b) =>
                            default(ApplOption< A, B, C>).Apply(
                                default(MOption< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Option<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Option<A>> ma,
            Func<A, TryOptionAsync<Option<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> Where< A>(this TryOptionAsync<Option<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Option<A>> Do(Option<A> a) => default(MTryOptionAsync<Option<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> Select< A, B>(this TryOptionAsync<Option<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<Option<B>>).ReturnAsync(_ => default(MOption<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<Option<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;Option&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<Option<A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> BindT< A, B>(this TryOptionAsync<Option<A>> ma, Func<A, Option<B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Bind<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> MapT< A, B>(this TryOptionAsync<Option<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Map<MTryOptionAsync<Option<B>>, TryOptionAsync<Option<B>>, MOption<B>, Option<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<Option<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<Option<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<Option<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;Option&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<Option<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<Option<A>>, TryOptionAsync<Option<A>>, MOption<A>, Option<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Option&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> FilterT< A>(this TryOptionAsync<Option<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Option<A>> Do(Option<A> a) => default(MTryOptionAsync<Option<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> PlusT<NUM,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> SubtractT<NUM,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> ProductT<NUM,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> DivideT<NUM,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Option<A>> AppendT<SEMI,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<Option<A>> x, TryOptionAsync<Option<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Option<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Option<A>> fa) =>
            default(ApplTryOptionAsync< Option<A>, Option<B>>).Apply(
                default(MTryOptionAsync< Func<Option<A>, Option<B>>>).ReturnAsync(
                    Task.FromResult<Func<Option<A>, Option<B>>>((Option<A> a) => 
                        default(ApplOption< A, B>).Apply(
                            default(MOption< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Option&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;Option&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Option&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Option<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Option<A>> fa, TryOptionAsync<Option<B>> fb) =>
            default(ApplTryOptionAsync< Option<A>, Option<B>, Option<C>>).Apply(
                default(MTryOptionAsync< Func<Option<A>, Func<Option<B>, Option<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Option<A>, Func<Option<B>, Option<C>>>>((Option<A> a) =>
                        (Option<B> b) =>
                            default(ApplOption< A, B, C>).Apply(
                                default(MOption< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for OptionUnsafe, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class OptionUnsafeT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<C>> SelectMany< A, B, C>(
            this OptionAsync<OptionUnsafe<A>> ma,
            Func<A, OptionAsync<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> Where< A>(this OptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f)
        {
            OptionAsync<OptionUnsafe<A>> Do(OptionUnsafe<A> a) => default(MOptionAsync<OptionUnsafe<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<B>> Select< A, B>(this OptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<OptionUnsafe<B>>).ReturnAsync(_ => default(MOptionUnsafe<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<OptionUnsafe<A>> ma) =>
            default(TransAsyncSync<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<B>> BindT< A, B>(this OptionAsync<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            default(TransAsyncSync<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Bind<MOptionAsync<OptionUnsafe<B>>, OptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<B>> MapT< A, B>(this OptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Map<MOptionAsync<OptionUnsafe<B>>, OptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<OptionUnsafe<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<OptionUnsafe<A>>, OptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> FilterT< A>(this OptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f)
        {
            OptionAsync<OptionUnsafe<A>> Do(OptionUnsafe<A> a) => default(MOptionAsync<OptionUnsafe<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> PlusT<NUM,  A>(this OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> SubtractT<NUM,  A>(this OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> ProductT<NUM,  A>(this OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> DivideT<NUM,  A>(this OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<A>> AppendT<SEMI,  A>(this OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<OptionUnsafe<A>> x, OptionAsync<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<OptionUnsafe<A>> fa) =>
            default(ApplOptionAsync< OptionUnsafe<A>, OptionUnsafe<B>>).Apply(
                default(MOptionAsync< Func<OptionUnsafe<A>, OptionUnsafe<B>>>).ReturnAsync(
                    Task.FromResult<Func<OptionUnsafe<A>, OptionUnsafe<B>>>((OptionUnsafe<A> a) => 
                        default(ApplOptionUnsafe< A, B>).Apply(
                            default(MOptionUnsafe< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<OptionUnsafe<A>> fa, OptionAsync<OptionUnsafe<B>> fb) =>
            default(ApplOptionAsync< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>).Apply(
                default(MOptionAsync< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>).ReturnAsync(
                    Task.FromResult<Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>((OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            default(ApplOptionUnsafe< A, B, C>).Apply(
                                default(MOptionUnsafe< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, OptionUnsafe<A>> ma,
            Func<A, EitherAsync<L, OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<A>> Where<L, A>(this EitherAsync<L, OptionUnsafe<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, OptionUnsafe<A>> Do(OptionUnsafe<A> a) => default(MEitherAsync<L, OptionUnsafe<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<B>> Select<L, A, B>(this EitherAsync<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, OptionUnsafe<B>>).ReturnAsync(_ => default(MOptionUnsafe<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, OptionUnsafe<A>>, EitherAsync<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, OptionUnsafe<A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, OptionUnsafe<A>>, EitherAsync<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<B>> BindT<L, A, B>(this EitherAsync<L, OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, OptionUnsafe<A>>, EitherAsync<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Bind<MEitherAsync<L, OptionUnsafe<B>>, EitherAsync<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<B>> MapT<L, A, B>(this EitherAsync<L, OptionUnsafe<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, OptionUnsafe<A>>, EitherAsync<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Map<MEitherAsync<L, OptionUnsafe<B>>, EitherAsync<L, OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, OptionUnsafe<A>>, EitherAsync<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, OptionUnsafe<A>>, EitherAsync<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, OptionUnsafe<A>>, EitherAsync<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, OptionUnsafe<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, OptionUnsafe<A>>, EitherAsync<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, OptionUnsafe<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, OptionUnsafe<A>>, EitherAsync<L, OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<A>> FilterT<L, A>(this EitherAsync<L, OptionUnsafe<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, OptionUnsafe<A>> Do(OptionUnsafe<A> a) => default(MEitherAsync<L, OptionUnsafe<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<A>> PlusT<NUM, L, A>(this EitherAsync<L, OptionUnsafe<A>> x, EitherAsync<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<A>> SubtractT<NUM, L, A>(this EitherAsync<L, OptionUnsafe<A>> x, EitherAsync<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<A>> ProductT<NUM, L, A>(this EitherAsync<L, OptionUnsafe<A>> x, EitherAsync<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<A>> DivideT<NUM, L, A>(this EitherAsync<L, OptionUnsafe<A>> x, EitherAsync<L, OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<A>> AppendT<SEMI, L, A>(this EitherAsync<L, OptionUnsafe<A>> x, EitherAsync<L, OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, OptionUnsafe<A>> x, EitherAsync<L, OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, OptionUnsafe<A>> x, EitherAsync<L, OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, OptionUnsafe<A>> fa) =>
            default(ApplEitherAsync<L, OptionUnsafe<A>, OptionUnsafe<B>>).Apply(
                default(MEitherAsync<L, Func<OptionUnsafe<A>, OptionUnsafe<B>>>).ReturnAsync(
                    Task.FromResult<Func<OptionUnsafe<A>, OptionUnsafe<B>>>((OptionUnsafe<A> a) => 
                        default(ApplOptionUnsafe< A, B>).Apply(
                            default(MOptionUnsafe< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, OptionUnsafe<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, OptionUnsafe<A>> fa, EitherAsync<L, OptionUnsafe<B>> fb) =>
            default(ApplEitherAsync<L, OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>).Apply(
                default(MEitherAsync<L, Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>).ReturnAsync(
                    Task.FromResult<Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>((OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            default(ApplOptionUnsafe< A, B, C>).Apply(
                                default(MOptionUnsafe< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<OptionUnsafe<C>> SelectMany< A, B, C>(
            this Task<OptionUnsafe<A>> ma,
            Func<A, Task<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> Where< A>(this Task<OptionUnsafe<A>> ma, Func<A, bool> f)
        {
            Task<OptionUnsafe<A>> Do(OptionUnsafe<A> a) => default(MTask<OptionUnsafe<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> Select< A, B>(this Task<OptionUnsafe<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<OptionUnsafe<B>>).ReturnAsync(_ => default(MOptionUnsafe<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<OptionUnsafe<A>> ma) =>
            default(TransAsyncSync<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> BindT< A, B>(this Task<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            default(TransAsyncSync<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Bind<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> MapT< A, B>(this Task<OptionUnsafe<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Map<MTask<OptionUnsafe<B>>, Task<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<OptionUnsafe<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<OptionUnsafe<A>>, Task<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> FilterT< A>(this Task<OptionUnsafe<A>> ma, Func<A, bool> f)
        {
            Task<OptionUnsafe<A>> Do(OptionUnsafe<A> a) => default(MTask<OptionUnsafe<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> PlusT<NUM,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> SubtractT<NUM,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> ProductT<NUM,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> DivideT<NUM,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<OptionUnsafe<A>> AppendT<SEMI,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<OptionUnsafe<A>> x, Task<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, Task<OptionUnsafe<A>> fa) =>
            default(ApplTask< OptionUnsafe<A>, OptionUnsafe<B>>).Apply(
                default(MTask< Func<OptionUnsafe<A>, OptionUnsafe<B>>>).ReturnAsync(
                    Task.FromResult<Func<OptionUnsafe<A>, OptionUnsafe<B>>>((OptionUnsafe<A> a) => 
                        default(ApplOptionUnsafe< A, B>).Apply(
                            default(MOptionUnsafe< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<OptionUnsafe<A>> fa, Task<OptionUnsafe<B>> fb) =>
            default(ApplTask< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>).Apply(
                default(MTask< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>).ReturnAsync(
                    Task.FromResult<Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>((OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            default(ApplOptionUnsafe< A, B, C>).Apply(
                                default(MOptionUnsafe< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<C>> SelectMany< A, B, C>(
            this TryAsync<OptionUnsafe<A>> ma,
            Func<A, TryAsync<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> Where< A>(this TryAsync<OptionUnsafe<A>> ma, Func<A, bool> f)
        {
            TryAsync<OptionUnsafe<A>> Do(OptionUnsafe<A> a) => default(MTryAsync<OptionUnsafe<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> Select< A, B>(this TryAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<OptionUnsafe<B>>).ReturnAsync(_ => default(MOptionUnsafe<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<OptionUnsafe<A>> ma) =>
            default(TransAsyncSync<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> BindT< A, B>(this TryAsync<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            default(TransAsyncSync<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Bind<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> MapT< A, B>(this TryAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Map<MTryAsync<OptionUnsafe<B>>, TryAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<OptionUnsafe<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<OptionUnsafe<A>>, TryAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> FilterT< A>(this TryAsync<OptionUnsafe<A>> ma, Func<A, bool> f)
        {
            TryAsync<OptionUnsafe<A>> Do(OptionUnsafe<A> a) => default(MTryAsync<OptionUnsafe<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> PlusT<NUM,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> SubtractT<NUM,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> ProductT<NUM,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> DivideT<NUM,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<A>> AppendT<SEMI,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<OptionUnsafe<A>> x, TryAsync<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<OptionUnsafe<A>> fa) =>
            default(ApplTryAsync< OptionUnsafe<A>, OptionUnsafe<B>>).Apply(
                default(MTryAsync< Func<OptionUnsafe<A>, OptionUnsafe<B>>>).ReturnAsync(
                    Task.FromResult<Func<OptionUnsafe<A>, OptionUnsafe<B>>>((OptionUnsafe<A> a) => 
                        default(ApplOptionUnsafe< A, B>).Apply(
                            default(MOptionUnsafe< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<OptionUnsafe<A>> fa, TryAsync<OptionUnsafe<B>> fb) =>
            default(ApplTryAsync< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>).Apply(
                default(MTryAsync< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>).ReturnAsync(
                    Task.FromResult<Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>((OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            default(ApplOptionUnsafe< A, B, C>).Apply(
                                default(MOptionUnsafe< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<C>> SelectMany< A, B, C>(
            this TryOptionAsync<OptionUnsafe<A>> ma,
            Func<A, TryOptionAsync<OptionUnsafe<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MOptionUnsafe<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> Where< A>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<OptionUnsafe<A>> Do(OptionUnsafe<A> a) => default(MTryOptionAsync<OptionUnsafe<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> Select< A, B>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<OptionUnsafe<B>>).ReturnAsync(_ => default(MOptionUnsafe<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<OptionUnsafe<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<OptionUnsafe<A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> BindT< A, B>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, OptionUnsafe<B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Bind<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> MapT< A, B>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Map<MTryOptionAsync<OptionUnsafe<B>>, TryOptionAsync<OptionUnsafe<B>>, MOptionUnsafe<B>, OptionUnsafe<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<OptionUnsafe<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<OptionUnsafe<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<OptionUnsafe<A>>, TryOptionAsync<OptionUnsafe<A>>, MOptionUnsafe<A>, OptionUnsafe<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> FilterT< A>(this TryOptionAsync<OptionUnsafe<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<OptionUnsafe<A>> Do(OptionUnsafe<A> a) => default(MTryOptionAsync<OptionUnsafe<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> PlusT<NUM,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> SubtractT<NUM,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> ProductT<NUM,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> DivideT<NUM,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<A>> AppendT<SEMI,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<OptionUnsafe<A>> x, TryOptionAsync<OptionUnsafe<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<OptionUnsafe<A>> fa) =>
            default(ApplTryOptionAsync< OptionUnsafe<A>, OptionUnsafe<B>>).Apply(
                default(MTryOptionAsync< Func<OptionUnsafe<A>, OptionUnsafe<B>>>).ReturnAsync(
                    Task.FromResult<Func<OptionUnsafe<A>, OptionUnsafe<B>>>((OptionUnsafe<A> a) => 
                        default(ApplOptionUnsafe< A, B>).Apply(
                            default(MOptionUnsafe< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;OptionUnsafe&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;OptionUnsafe&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<OptionUnsafe<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<OptionUnsafe<A>> fa, TryOptionAsync<OptionUnsafe<B>> fb) =>
            default(ApplTryOptionAsync< OptionUnsafe<A>, OptionUnsafe<B>, OptionUnsafe<C>>).Apply(
                default(MTryOptionAsync< Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>).ReturnAsync(
                    Task.FromResult<Func<OptionUnsafe<A>, Func<OptionUnsafe<B>, OptionUnsafe<C>>>>((OptionUnsafe<A> a) =>
                        (OptionUnsafe<B> b) =>
                            default(ApplOptionUnsafe< A, B, C>).Apply(
                                default(MOptionUnsafe< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for Either, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class EitherT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Either<L, C>> SelectMany<L, A, B, C>(
            this OptionAsync<Either<L, A>> ma,
            Func<A, OptionAsync<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> Where<L, A>(this OptionAsync<Either<L, A>> ma, Func<A, bool> f)
        {
            OptionAsync<Either<L, A>> Do(Either<L, A> a) => default(MOptionAsync<Either<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Either<L, B>> Select<L, A, B>(this OptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<Either<L, B>>).ReturnAsync(_ => default(MEither<L, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this OptionAsync<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this OptionAsync<Either<L, A>> ma) =>
            default(TransAsyncSync<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Either<L, B>> BindT<L, A, B>(this OptionAsync<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            default(TransAsyncSync<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Bind<MOptionAsync<Either<L, B>>, OptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Either<L, B>> MapT<L, A, B>(this OptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Map<MOptionAsync<Either<L, B>>, OptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this OptionAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this OptionAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this OptionAsync<Either<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this OptionAsync<Either<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this OptionAsync<Either<L, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<Either<L, A>>, OptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> FilterT<L, A>(this OptionAsync<Either<L, A>> ma, Func<A, bool> f)
        {
            OptionAsync<Either<L, A>> Do(Either<L, A> a) => default(MOptionAsync<Either<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> PlusT<NUM, L, A>(this OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> SubtractT<NUM, L, A>(this OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> ProductT<NUM, L, A>(this OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> DivideT<NUM, L, A>(this OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Either<L, A>> AppendT<SEMI, L, A>(this OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this OptionAsync<Either<L, A>> x, OptionAsync<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, OptionAsync<Either<L, A>> fa) =>
            default(ApplOptionAsync< Either<L, A>, Either<L, B>>).Apply(
                default(MOptionAsync< Func<Either<L, A>, Either<L, B>>>).ReturnAsync(
                    Task.FromResult<Func<Either<L, A>, Either<L, B>>>((Either<L, A> a) => 
                        default(ApplEither<L, A, B>).Apply(
                            default(MEither<L, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, OptionAsync<Either<L, A>> fa, OptionAsync<Either<L, B>> fb) =>
            default(ApplOptionAsync< Either<L, A>, Either<L, B>, Either<L, C>>).Apply(
                default(MOptionAsync< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>).ReturnAsync(
                    Task.FromResult<Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>((Either<L, A> a) =>
                        (Either<L, B> b) =>
                            default(ApplEither<L, A, B, C>).Apply(
                                default(MEither<L, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, Either<L, C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, Either<L, A>> ma,
            Func<A, EitherAsync<L, Either<L, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Either<L, A>> Where<L, A>(this EitherAsync<L, Either<L, A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Either<L, A>> Do(Either<L, A> a) => default(MEitherAsync<L, Either<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Either<L, B>> Select<L, A, B>(this EitherAsync<L, Either<L, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, Either<L, B>>).ReturnAsync(_ => default(MEither<L, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, Either<L, A>>, EitherAsync<L, Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, Either<L, A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, Either<L, A>>, EitherAsync<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Either<L, B>> BindT<L, A, B>(this EitherAsync<L, Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, Either<L, A>>, EitherAsync<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Bind<MEitherAsync<L, Either<L, B>>, EitherAsync<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Either<L, B>> MapT<L, A, B>(this EitherAsync<L, Either<L, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, Either<L, A>>, EitherAsync<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Map<MEitherAsync<L, Either<L, B>>, EitherAsync<L, Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Either<L, A>>, EitherAsync<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, Either<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Either<L, A>>, EitherAsync<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, Either<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Either<L, A>>, EitherAsync<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, Either<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Either<L, A>>, EitherAsync<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, Either<L, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, Either<L, A>>, EitherAsync<L, Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Either<L, A>> FilterT<L, A>(this EitherAsync<L, Either<L, A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Either<L, A>> Do(Either<L, A> a) => default(MEitherAsync<L, Either<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, Either<L, A>> PlusT<NUM, L, A>(this EitherAsync<L, Either<L, A>> x, EitherAsync<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, Either<L, A>> SubtractT<NUM, L, A>(this EitherAsync<L, Either<L, A>> x, EitherAsync<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, Either<L, A>> ProductT<NUM, L, A>(this EitherAsync<L, Either<L, A>> x, EitherAsync<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, Either<L, A>> DivideT<NUM, L, A>(this EitherAsync<L, Either<L, A>> x, EitherAsync<L, Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, Either<L, A>> AppendT<SEMI, L, A>(this EitherAsync<L, Either<L, A>> x, EitherAsync<L, Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, Either<L, A>> x, EitherAsync<L, Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, Either<L, A>> x, EitherAsync<L, Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, Either<L, A>> fa) =>
            default(ApplEitherAsync<L, Either<L, A>, Either<L, B>>).Apply(
                default(MEitherAsync<L, Func<Either<L, A>, Either<L, B>>>).ReturnAsync(
                    Task.FromResult<Func<Either<L, A>, Either<L, B>>>((Either<L, A> a) => 
                        default(ApplEither<L, A, B>).Apply(
                            default(MEither<L, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, Either<L, A>> fa, EitherAsync<L, Either<L, B>> fb) =>
            default(ApplEitherAsync<L, Either<L, A>, Either<L, B>, Either<L, C>>).Apply(
                default(MEitherAsync<L, Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>).ReturnAsync(
                    Task.FromResult<Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>((Either<L, A> a) =>
                        (Either<L, B> b) =>
                            default(ApplEither<L, A, B, C>).Apply(
                                default(MEither<L, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Either<L, C>> SelectMany<L, A, B, C>(
            this Task<Either<L, A>> ma,
            Func<A, Task<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Either<L, A>> Where<L, A>(this Task<Either<L, A>> ma, Func<A, bool> f)
        {
            Task<Either<L, A>> Do(Either<L, A> a) => default(MTask<Either<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Either<L, B>> Select<L, A, B>(this Task<Either<L, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<Either<L, B>>).ReturnAsync(_ => default(MEither<L, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this Task<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this Task<Either<L, A>> ma) =>
            default(TransAsyncSync<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Either<L, B>> BindT<L, A, B>(this Task<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            default(TransAsyncSync<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Bind<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Either<L, B>> MapT<L, A, B>(this Task<Either<L, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Map<MTask<Either<L, B>>, Task<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this Task<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this Task<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this Task<Either<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this Task<Either<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this Task<Either<L, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<Either<L, A>>, Task<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Either<L, A>> FilterT<L, A>(this Task<Either<L, A>> ma, Func<A, bool> f)
        {
            Task<Either<L, A>> Do(Either<L, A> a) => default(MTask<Either<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Either<L, A>> PlusT<NUM, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Either<L, A>> SubtractT<NUM, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Either<L, A>> ProductT<NUM, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Either<L, A>> DivideT<NUM, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Either<L, A>> AppendT<SEMI, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this Task<Either<L, A>> x, Task<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Task&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Task<Either<L, A>> fa) =>
            default(ApplTask< Either<L, A>, Either<L, B>>).Apply(
                default(MTask< Func<Either<L, A>, Either<L, B>>>).ReturnAsync(
                    Task.FromResult<Func<Either<L, A>, Either<L, B>>>((Either<L, A> a) => 
                        default(ApplEither<L, A, B>).Apply(
                            default(MEither<L, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`Task&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Task<Either<L, A>> fa, Task<Either<L, B>> fb) =>
            default(ApplTask< Either<L, A>, Either<L, B>, Either<L, C>>).Apply(
                default(MTask< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>).ReturnAsync(
                    Task.FromResult<Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>((Either<L, A> a) =>
                        (Either<L, B> b) =>
                            default(ApplEither<L, A, B, C>).Apply(
                                default(MEither<L, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Either<L, C>> SelectMany<L, A, B, C>(
            this TryAsync<Either<L, A>> ma,
            Func<A, TryAsync<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Either<L, A>> Where<L, A>(this TryAsync<Either<L, A>> ma, Func<A, bool> f)
        {
            TryAsync<Either<L, A>> Do(Either<L, A> a) => default(MTryAsync<Either<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Either<L, B>> Select<L, A, B>(this TryAsync<Either<L, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<Either<L, B>>).ReturnAsync(_ => default(MEither<L, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this TryAsync<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this TryAsync<Either<L, A>> ma) =>
            default(TransAsyncSync<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Either<L, B>> BindT<L, A, B>(this TryAsync<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            default(TransAsyncSync<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Bind<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Either<L, B>> MapT<L, A, B>(this TryAsync<Either<L, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Map<MTryAsync<Either<L, B>>, TryAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this TryAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this TryAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this TryAsync<Either<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this TryAsync<Either<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this TryAsync<Either<L, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<Either<L, A>>, TryAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Either<L, A>> FilterT<L, A>(this TryAsync<Either<L, A>> ma, Func<A, bool> f)
        {
            TryAsync<Either<L, A>> Do(Either<L, A> a) => default(MTryAsync<Either<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Either<L, A>> PlusT<NUM, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Either<L, A>> SubtractT<NUM, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Either<L, A>> ProductT<NUM, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Either<L, A>> DivideT<NUM, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Either<L, A>> AppendT<SEMI, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this TryAsync<Either<L, A>> x, TryAsync<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryAsync<Either<L, A>> fa) =>
            default(ApplTryAsync< Either<L, A>, Either<L, B>>).Apply(
                default(MTryAsync< Func<Either<L, A>, Either<L, B>>>).ReturnAsync(
                    Task.FromResult<Func<Either<L, A>, Either<L, B>>>((Either<L, A> a) => 
                        default(ApplEither<L, A, B>).Apply(
                            default(MEither<L, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryAsync<Either<L, A>> fa, TryAsync<Either<L, B>> fb) =>
            default(ApplTryAsync< Either<L, A>, Either<L, B>, Either<L, C>>).Apply(
                default(MTryAsync< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>).ReturnAsync(
                    Task.FromResult<Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>((Either<L, A> a) =>
                        (Either<L, B> b) =>
                            default(ApplEither<L, A, B, C>).Apply(
                                default(MEither<L, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Either<L, C>> SelectMany<L, A, B, C>(
            this TryOptionAsync<Either<L, A>> ma,
            Func<A, TryOptionAsync<Either<L, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MEither<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> Where<L, A>(this TryOptionAsync<Either<L, A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Either<L, A>> Do(Either<L, A> a) => default(MTryOptionAsync<Either<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> Select<L, A, B>(this TryOptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<Either<L, B>>).ReturnAsync(_ => default(MEither<L, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this TryOptionAsync<Either<L, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this TryOptionAsync<Either<L, A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> BindT<L, A, B>(this TryOptionAsync<Either<L, A>> ma, Func<A, Either<L, B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Bind<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> MapT<L, A, B>(this TryOptionAsync<Either<L, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Map<MTryOptionAsync<Either<L, B>>, TryOptionAsync<Either<L, B>>, MEither<L, B>, Either<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this TryOptionAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this TryOptionAsync<Either<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this TryOptionAsync<Either<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this TryOptionAsync<Either<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this TryOptionAsync<Either<L, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<Either<L, A>>, TryOptionAsync<Either<L, A>>, MEither<L, A>, Either<L, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> FilterT<L, A>(this TryOptionAsync<Either<L, A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Either<L, A>> Do(Either<L, A> a) => default(MTryOptionAsync<Either<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> PlusT<NUM, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> SubtractT<NUM, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> ProductT<NUM, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> DivideT<NUM, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, A>> AppendT<SEMI, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this TryOptionAsync<Either<L, A>> x, TryOptionAsync<Either<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryOptionAsync<Either<L, A>> fa) =>
            default(ApplTryOptionAsync< Either<L, A>, Either<L, B>>).Apply(
                default(MTryOptionAsync< Func<Either<L, A>, Either<L, B>>>).ReturnAsync(
                    Task.FromResult<Func<Either<L, A>, Either<L, B>>>((Either<L, A> a) => 
                        default(ApplEither<L, A, B>).Apply(
                            default(MEither<L, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;Either&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Either&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Either<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Either<L, A>> fa, TryOptionAsync<Either<L, B>> fb) =>
            default(ApplTryOptionAsync< Either<L, A>, Either<L, B>, Either<L, C>>).Apply(
                default(MTryOptionAsync< Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>).ReturnAsync(
                    Task.FromResult<Func<Either<L, A>, Func<Either<L, B>, Either<L, C>>>>((Either<L, A> a) =>
                        (Either<L, B> b) =>
                            default(ApplEither<L, A, B, C>).Apply(
                                default(MEither<L, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for EitherUnsafe, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class EitherUnsafeT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this OptionAsync<EitherUnsafe<L, A>> ma,
            Func<A, OptionAsync<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> Where<L, A>(this OptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f)
        {
            OptionAsync<EitherUnsafe<L, A>> Do(EitherUnsafe<L, A> a) => default(MOptionAsync<EitherUnsafe<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, B>> Select<L, A, B>(this OptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<EitherUnsafe<L, B>>).ReturnAsync(_ => default(MEitherUnsafe<L, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this OptionAsync<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this OptionAsync<EitherUnsafe<L, A>> ma) =>
            default(TransAsyncSync<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, B>> BindT<L, A, B>(this OptionAsync<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            default(TransAsyncSync<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Bind<MOptionAsync<EitherUnsafe<L, B>>, OptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, B>> MapT<L, A, B>(this OptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Map<MOptionAsync<EitherUnsafe<L, B>>, OptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this OptionAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this OptionAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this OptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this OptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this OptionAsync<EitherUnsafe<L, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<EitherUnsafe<L, A>>, OptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> FilterT<L, A>(this OptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f)
        {
            OptionAsync<EitherUnsafe<L, A>> Do(EitherUnsafe<L, A> a) => default(MOptionAsync<EitherUnsafe<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this OptionAsync<EitherUnsafe<L, A>> x, OptionAsync<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, OptionAsync<EitherUnsafe<L, A>> fa) =>
            default(ApplOptionAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>>).Apply(
                default(MOptionAsync< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>).ReturnAsync(
                    Task.FromResult<Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>((EitherUnsafe<L, A> a) => 
                        default(ApplEitherUnsafe<L, A, B>).Apply(
                            default(MEitherUnsafe<L, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, OptionAsync<EitherUnsafe<L, A>> fa, OptionAsync<EitherUnsafe<L, B>> fb) =>
            default(ApplOptionAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>).Apply(
                default(MOptionAsync< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>).ReturnAsync(
                    Task.FromResult<Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>((EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            default(ApplEitherUnsafe<L, A, B, C>).Apply(
                                default(MEitherUnsafe<L, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, EitherUnsafe<L, A>> ma,
            Func<A, EitherAsync<L, EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, A>> Where<L, A>(this EitherAsync<L, EitherUnsafe<L, A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, EitherUnsafe<L, A>> Do(EitherUnsafe<L, A> a) => default(MEitherAsync<L, EitherUnsafe<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, B>> Select<L, A, B>(this EitherAsync<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, EitherUnsafe<L, B>>).ReturnAsync(_ => default(MEitherUnsafe<L, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, EitherUnsafe<L, A>>, EitherAsync<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, EitherUnsafe<L, A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, EitherUnsafe<L, A>>, EitherAsync<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, B>> BindT<L, A, B>(this EitherAsync<L, EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, EitherUnsafe<L, A>>, EitherAsync<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Bind<MEitherAsync<L, EitherUnsafe<L, B>>, EitherAsync<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, B>> MapT<L, A, B>(this EitherAsync<L, EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, EitherUnsafe<L, A>>, EitherAsync<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Map<MEitherAsync<L, EitherUnsafe<L, B>>, EitherAsync<L, EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, EitherUnsafe<L, A>>, EitherAsync<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, EitherUnsafe<L, A>>, EitherAsync<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, EitherUnsafe<L, A>>, EitherAsync<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, EitherUnsafe<L, A>>, EitherAsync<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, EitherUnsafe<L, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, EitherUnsafe<L, A>>, EitherAsync<L, EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, A>> FilterT<L, A>(this EitherAsync<L, EitherUnsafe<L, A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, EitherUnsafe<L, A>> Do(EitherUnsafe<L, A> a) => default(MEitherAsync<L, EitherUnsafe<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, A>> PlusT<NUM, L, A>(this EitherAsync<L, EitherUnsafe<L, A>> x, EitherAsync<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this EitherAsync<L, EitherUnsafe<L, A>> x, EitherAsync<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, A>> ProductT<NUM, L, A>(this EitherAsync<L, EitherUnsafe<L, A>> x, EitherAsync<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, A>> DivideT<NUM, L, A>(this EitherAsync<L, EitherUnsafe<L, A>> x, EitherAsync<L, EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this EitherAsync<L, EitherUnsafe<L, A>> x, EitherAsync<L, EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, EitherUnsafe<L, A>> x, EitherAsync<L, EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, EitherUnsafe<L, A>> x, EitherAsync<L, EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, EitherUnsafe<L, A>> fa) =>
            default(ApplEitherAsync<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>>).Apply(
                default(MEitherAsync<L, Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>).ReturnAsync(
                    Task.FromResult<Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>((EitherUnsafe<L, A> a) => 
                        default(ApplEitherUnsafe<L, A, B>).Apply(
                            default(MEitherUnsafe<L, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, EitherUnsafe<L, A>> fa, EitherAsync<L, EitherUnsafe<L, B>> fb) =>
            default(ApplEitherAsync<L, EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>).Apply(
                default(MEitherAsync<L, Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>).ReturnAsync(
                    Task.FromResult<Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>((EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            default(ApplEitherUnsafe<L, A, B, C>).Apply(
                                default(MEitherUnsafe<L, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this Task<EitherUnsafe<L, A>> ma,
            Func<A, Task<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> Where<L, A>(this Task<EitherUnsafe<L, A>> ma, Func<A, bool> f)
        {
            Task<EitherUnsafe<L, A>> Do(EitherUnsafe<L, A> a) => default(MTask<EitherUnsafe<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> Select<L, A, B>(this Task<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<EitherUnsafe<L, B>>).ReturnAsync(_ => default(MEitherUnsafe<L, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this Task<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this Task<EitherUnsafe<L, A>> ma) =>
            default(TransAsyncSync<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> BindT<L, A, B>(this Task<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            default(TransAsyncSync<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Bind<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> MapT<L, A, B>(this Task<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Map<MTask<EitherUnsafe<L, B>>, Task<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this Task<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this Task<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this Task<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this Task<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this Task<EitherUnsafe<L, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<EitherUnsafe<L, A>>, Task<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> FilterT<L, A>(this Task<EitherUnsafe<L, A>> ma, Func<A, bool> f)
        {
            Task<EitherUnsafe<L, A>> Do(EitherUnsafe<L, A> a) => default(MTask<EitherUnsafe<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this Task<EitherUnsafe<L, A>> x, Task<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, Task<EitherUnsafe<L, A>> fa) =>
            default(ApplTask< EitherUnsafe<L, A>, EitherUnsafe<L, B>>).Apply(
                default(MTask< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>).ReturnAsync(
                    Task.FromResult<Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>((EitherUnsafe<L, A> a) => 
                        default(ApplEitherUnsafe<L, A, B>).Apply(
                            default(MEitherUnsafe<L, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`Task&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, Task<EitherUnsafe<L, A>> fa, Task<EitherUnsafe<L, B>> fb) =>
            default(ApplTask< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>).Apply(
                default(MTask< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>).ReturnAsync(
                    Task.FromResult<Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>((EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            default(ApplEitherUnsafe<L, A, B, C>).Apply(
                                default(MEitherUnsafe<L, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this TryAsync<EitherUnsafe<L, A>> ma,
            Func<A, TryAsync<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> Where<L, A>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f)
        {
            TryAsync<EitherUnsafe<L, A>> Do(EitherUnsafe<L, A> a) => default(MTryAsync<EitherUnsafe<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> Select<L, A, B>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<EitherUnsafe<L, B>>).ReturnAsync(_ => default(MEitherUnsafe<L, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this TryAsync<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this TryAsync<EitherUnsafe<L, A>> ma) =>
            default(TransAsyncSync<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> BindT<L, A, B>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            default(TransAsyncSync<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Bind<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> MapT<L, A, B>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Map<MTryAsync<EitherUnsafe<L, B>>, TryAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this TryAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this TryAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this TryAsync<EitherUnsafe<L, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<EitherUnsafe<L, A>>, TryAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> FilterT<L, A>(this TryAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f)
        {
            TryAsync<EitherUnsafe<L, A>> Do(EitherUnsafe<L, A> a) => default(MTryAsync<EitherUnsafe<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this TryAsync<EitherUnsafe<L, A>> x, TryAsync<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryAsync<EitherUnsafe<L, A>> fa) =>
            default(ApplTryAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>>).Apply(
                default(MTryAsync< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>).ReturnAsync(
                    Task.FromResult<Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>((EitherUnsafe<L, A> a) => 
                        default(ApplEitherUnsafe<L, A, B>).Apply(
                            default(MEitherUnsafe<L, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryAsync<EitherUnsafe<L, A>> fa, TryAsync<EitherUnsafe<L, B>> fb) =>
            default(ApplTryAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>).Apply(
                default(MTryAsync< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>).ReturnAsync(
                    Task.FromResult<Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>((EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            default(ApplEitherUnsafe<L, A, B, C>).Apply(
                                default(MEitherUnsafe<L, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, C>> SelectMany<L, A, B, C>(
            this TryOptionAsync<EitherUnsafe<L, A>> ma,
            Func<A, TryOptionAsync<EitherUnsafe<L, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MEitherUnsafe<L, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> Where<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<EitherUnsafe<L, A>> Do(EitherUnsafe<L, A> a) => default(MTryOptionAsync<EitherUnsafe<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> Select<L, A, B>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<EitherUnsafe<L, B>>).ReturnAsync(_ => default(MEitherUnsafe<L, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> BindT<L, A, B>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, EitherUnsafe<L, B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Bind<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> MapT<L, A, B>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Map<MTryOptionAsync<EitherUnsafe<L, B>>, TryOptionAsync<EitherUnsafe<L, B>>, MEitherUnsafe<L, B>, EitherUnsafe<L, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<EitherUnsafe<L, A>>, TryOptionAsync<EitherUnsafe<L, A>>, MEitherUnsafe<L, A>, EitherUnsafe<L, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> FilterT<L, A>(this TryOptionAsync<EitherUnsafe<L, A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<EitherUnsafe<L, A>> Do(EitherUnsafe<L, A> a) => default(MTryOptionAsync<EitherUnsafe<L, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> PlusT<NUM, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> SubtractT<NUM, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> ProductT<NUM, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> DivideT<NUM, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, A>> AppendT<SEMI, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this TryOptionAsync<EitherUnsafe<L, A>> x, TryOptionAsync<EitherUnsafe<L, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, B>> ApplyT<L, A, B>(this Func<A, B> fab, TryOptionAsync<EitherUnsafe<L, A>> fa) =>
            default(ApplTryOptionAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>>).Apply(
                default(MTryOptionAsync< Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>).ReturnAsync(
                    Task.FromResult<Func<EitherUnsafe<L, A>, EitherUnsafe<L, B>>>((EitherUnsafe<L, A> a) => 
                        default(ApplEitherUnsafe<L, A, B>).Apply(
                            default(MEitherUnsafe<L, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;EitherUnsafe&lt;L, A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;EitherUnsafe&lt;L, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<EitherUnsafe<L, C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<EitherUnsafe<L, A>> fa, TryOptionAsync<EitherUnsafe<L, B>> fb) =>
            default(ApplTryOptionAsync< EitherUnsafe<L, A>, EitherUnsafe<L, B>, EitherUnsafe<L, C>>).Apply(
                default(MTryOptionAsync< Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>).ReturnAsync(
                    Task.FromResult<Func<EitherUnsafe<L, A>, Func<EitherUnsafe<L, B>, EitherUnsafe<L, C>>>>((EitherUnsafe<L, A> a) =>
                        (EitherUnsafe<L, B> b) =>
                            default(ApplEitherUnsafe<L, A, B, C>).Apply(
                                default(MEitherUnsafe<L, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for Try, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Try<C>> SelectMany< A, B, C>(
            this OptionAsync<Try<A>> ma,
            Func<A, OptionAsync<Try<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Try<A>> Where< A>(this OptionAsync<Try<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Try<A>> Do(Try<A> a) => default(MOptionAsync<Try<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Try<B>> Select< A, B>(this OptionAsync<Try<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<Try<B>>).ReturnAsync(_ => default(MTry<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<Try<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<Try<A>> ma) =>
            default(TransAsyncSync<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Try<B>> BindT< A, B>(this OptionAsync<Try<A>> ma, Func<A, Try<B>> f) =>
            default(TransAsyncSync<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Bind<MOptionAsync<Try<B>>, OptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Try<B>> MapT< A, B>(this OptionAsync<Try<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Map<MOptionAsync<Try<B>>, OptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<Try<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<Try<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<Try<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<Try<A>>, OptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Try<A>> FilterT< A>(this OptionAsync<Try<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Try<A>> Do(Try<A> a) => default(MOptionAsync<Try<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Try<A>> PlusT<NUM,  A>(this OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Try<A>> SubtractT<NUM,  A>(this OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Try<A>> ProductT<NUM,  A>(this OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Try<A>> DivideT<NUM,  A>(this OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Try<A>> AppendT<SEMI,  A>(this OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<Try<A>> x, OptionAsync<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Try<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<Try<A>> fa) =>
            default(ApplOptionAsync< Try<A>, Try<B>>).Apply(
                default(MOptionAsync< Func<Try<A>, Try<B>>>).ReturnAsync(
                    Task.FromResult<Func<Try<A>, Try<B>>>((Try<A> a) => 
                        default(ApplTry< A, B>).Apply(
                            default(MTry< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<Try<A>> fa, OptionAsync<Try<B>> fb) =>
            default(ApplOptionAsync< Try<A>, Try<B>, Try<C>>).Apply(
                default(MOptionAsync< Func<Try<A>, Func<Try<B>, Try<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Try<A>, Func<Try<B>, Try<C>>>>((Try<A> a) =>
                        (Try<B> b) =>
                            default(ApplTry< A, B, C>).Apply(
                                default(MTry< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, Try<C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, Try<A>> ma,
            Func<A, EitherAsync<L, Try<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Try<A>> Where<L, A>(this EitherAsync<L, Try<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Try<A>> Do(Try<A> a) => default(MEitherAsync<L, Try<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Try<B>> Select<L, A, B>(this EitherAsync<L, Try<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, Try<B>>).ReturnAsync(_ => default(MTry<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, Try<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, Try<A>>, EitherAsync<L, Try<A>>, MTry<A>, Try<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, Try<A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, Try<A>>, EitherAsync<L, Try<A>>, MTry<A>, Try<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Try<B>> BindT<L, A, B>(this EitherAsync<L, Try<A>> ma, Func<A, Try<B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, Try<A>>, EitherAsync<L, Try<A>>, MTry<A>, Try<A>, A>)
                .Bind<MEitherAsync<L, Try<B>>, EitherAsync<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Try<B>> MapT<L, A, B>(this EitherAsync<L, Try<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, Try<A>>, EitherAsync<L, Try<A>>, MTry<A>, Try<A>, A>)
                .Map<MEitherAsync<L, Try<B>>, EitherAsync<L, Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Try<A>>, EitherAsync<L, Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, Try<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Try<A>>, EitherAsync<L, Try<A>>, MTry<A>, Try<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, Try<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Try<A>>, EitherAsync<L, Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, Try<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Try<A>>, EitherAsync<L, Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, Try<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, Try<A>>, EitherAsync<L, Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Try<A>> FilterT<L, A>(this EitherAsync<L, Try<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Try<A>> Do(Try<A> a) => default(MEitherAsync<L, Try<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, Try<A>> PlusT<NUM, L, A>(this EitherAsync<L, Try<A>> x, EitherAsync<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, Try<A>> SubtractT<NUM, L, A>(this EitherAsync<L, Try<A>> x, EitherAsync<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, Try<A>> ProductT<NUM, L, A>(this EitherAsync<L, Try<A>> x, EitherAsync<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, Try<A>> DivideT<NUM, L, A>(this EitherAsync<L, Try<A>> x, EitherAsync<L, Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, Try<A>> AppendT<SEMI, L, A>(this EitherAsync<L, Try<A>> x, EitherAsync<L, Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, Try<A>> x, EitherAsync<L, Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, Try<A>> x, EitherAsync<L, Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Try&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, Try<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, Try<A>> fa) =>
            default(ApplEitherAsync<L, Try<A>, Try<B>>).Apply(
                default(MEitherAsync<L, Func<Try<A>, Try<B>>>).ReturnAsync(
                    Task.FromResult<Func<Try<A>, Try<B>>>((Try<A> a) => 
                        default(ApplTry< A, B>).Apply(
                            default(MTry< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, Try&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, Try<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, Try<A>> fa, EitherAsync<L, Try<B>> fb) =>
            default(ApplEitherAsync<L, Try<A>, Try<B>, Try<C>>).Apply(
                default(MEitherAsync<L, Func<Try<A>, Func<Try<B>, Try<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Try<A>, Func<Try<B>, Try<C>>>>((Try<A> a) =>
                        (Try<B> b) =>
                            default(ApplTry< A, B, C>).Apply(
                                default(MTry< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Try<C>> SelectMany< A, B, C>(
            this Task<Try<A>> ma,
            Func<A, Task<Try<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Try<A>> Where< A>(this Task<Try<A>> ma, Func<A, bool> f)
        {
            Task<Try<A>> Do(Try<A> a) => default(MTask<Try<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Try<B>> Select< A, B>(this Task<Try<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<Try<B>>).ReturnAsync(_ => default(MTry<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<Try<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<Try<A>> ma) =>
            default(TransAsyncSync<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Try<B>> BindT< A, B>(this Task<Try<A>> ma, Func<A, Try<B>> f) =>
            default(TransAsyncSync<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>)
                .Bind<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Try<B>> MapT< A, B>(this Task<Try<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>)
                .Map<MTask<Try<B>>, Task<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<Try<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<Try<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<Try<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<Try<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<Try<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<Try<A>>, Task<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Try<A>> FilterT< A>(this Task<Try<A>> ma, Func<A, bool> f)
        {
            Task<Try<A>> Do(Try<A> a) => default(MTask<Try<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Try<A>> PlusT<NUM,  A>(this Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Try<A>> SubtractT<NUM,  A>(this Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Try<A>> ProductT<NUM,  A>(this Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Try<A>> DivideT<NUM,  A>(this Task<Try<A>> x, Task<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Try<A>> AppendT<SEMI,  A>(this Task<Try<A>> x, Task<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<Try<A>> x, Task<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<Try<A>> x, Task<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Try<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Try<A>> fa) =>
            default(ApplTask< Try<A>, Try<B>>).Apply(
                default(MTask< Func<Try<A>, Try<B>>>).ReturnAsync(
                    Task.FromResult<Func<Try<A>, Try<B>>>((Try<A> a) => 
                        default(ApplTry< A, B>).Apply(
                            default(MTry< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Try<A>> fa, Task<Try<B>> fb) =>
            default(ApplTask< Try<A>, Try<B>, Try<C>>).Apply(
                default(MTask< Func<Try<A>, Func<Try<B>, Try<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Try<A>, Func<Try<B>, Try<C>>>>((Try<A> a) =>
                        (Try<B> b) =>
                            default(ApplTry< A, B, C>).Apply(
                                default(MTry< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Try<C>> SelectMany< A, B, C>(
            this TryAsync<Try<A>> ma,
            Func<A, TryAsync<Try<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Try<A>> Where< A>(this TryAsync<Try<A>> ma, Func<A, bool> f)
        {
            TryAsync<Try<A>> Do(Try<A> a) => default(MTryAsync<Try<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Try<B>> Select< A, B>(this TryAsync<Try<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<Try<B>>).ReturnAsync(_ => default(MTry<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<Try<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<Try<A>> ma) =>
            default(TransAsyncSync<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Try<B>> BindT< A, B>(this TryAsync<Try<A>> ma, Func<A, Try<B>> f) =>
            default(TransAsyncSync<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Bind<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Try<B>> MapT< A, B>(this TryAsync<Try<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Map<MTryAsync<Try<B>>, TryAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<Try<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<Try<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<Try<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<Try<A>>, TryAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Try<A>> FilterT< A>(this TryAsync<Try<A>> ma, Func<A, bool> f)
        {
            TryAsync<Try<A>> Do(Try<A> a) => default(MTryAsync<Try<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Try<A>> PlusT<NUM,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Try<A>> SubtractT<NUM,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Try<A>> ProductT<NUM,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Try<A>> DivideT<NUM,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Try<A>> AppendT<SEMI,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<Try<A>> x, TryAsync<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Try<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Try<A>> fa) =>
            default(ApplTryAsync< Try<A>, Try<B>>).Apply(
                default(MTryAsync< Func<Try<A>, Try<B>>>).ReturnAsync(
                    Task.FromResult<Func<Try<A>, Try<B>>>((Try<A> a) => 
                        default(ApplTry< A, B>).Apply(
                            default(MTry< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Try<A>> fa, TryAsync<Try<B>> fb) =>
            default(ApplTryAsync< Try<A>, Try<B>, Try<C>>).Apply(
                default(MTryAsync< Func<Try<A>, Func<Try<B>, Try<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Try<A>, Func<Try<B>, Try<C>>>>((Try<A> a) =>
                        (Try<B> b) =>
                            default(ApplTry< A, B, C>).Apply(
                                default(MTry< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Try<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Try<A>> ma,
            Func<A, TryOptionAsync<Try<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MTry<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> Where< A>(this TryOptionAsync<Try<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Try<A>> Do(Try<A> a) => default(MTryOptionAsync<Try<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> Select< A, B>(this TryOptionAsync<Try<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<Try<B>>).ReturnAsync(_ => default(MTry<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<Try<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;Try&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<Try<A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> BindT< A, B>(this TryOptionAsync<Try<A>> ma, Func<A, Try<B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Bind<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> MapT< A, B>(this TryOptionAsync<Try<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Map<MTryOptionAsync<Try<B>>, TryOptionAsync<Try<B>>, MTry<B>, Try<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<Try<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<Try<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<Try<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;Try&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<Try<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<Try<A>>, TryOptionAsync<Try<A>>, MTry<A>, Try<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Try&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> FilterT< A>(this TryOptionAsync<Try<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Try<A>> Do(Try<A> a) => default(MTryOptionAsync<Try<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> PlusT<NUM,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> SubtractT<NUM,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> ProductT<NUM,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> DivideT<NUM,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Try<A>> AppendT<SEMI,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<Try<A>> x, TryOptionAsync<Try<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Try<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Try<A>> fa) =>
            default(ApplTryOptionAsync< Try<A>, Try<B>>).Apply(
                default(MTryOptionAsync< Func<Try<A>, Try<B>>>).ReturnAsync(
                    Task.FromResult<Func<Try<A>, Try<B>>>((Try<A> a) => 
                        default(ApplTry< A, B>).Apply(
                            default(MTry< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Try&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;Try&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Try&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Try<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Try<A>> fa, TryOptionAsync<Try<B>> fb) =>
            default(ApplTryOptionAsync< Try<A>, Try<B>, Try<C>>).Apply(
                default(MTryOptionAsync< Func<Try<A>, Func<Try<B>, Try<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Try<A>, Func<Try<B>, Try<C>>>>((Try<A> a) =>
                        (Try<B> b) =>
                            default(ApplTry< A, B, C>).Apply(
                                default(MTry< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for TryOption, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class TryOptionT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<TryOption<C>> SelectMany< A, B, C>(
            this OptionAsync<TryOption<A>> ma,
            Func<A, OptionAsync<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> Where< A>(this OptionAsync<TryOption<A>> ma, Func<A, bool> f)
        {
            OptionAsync<TryOption<A>> Do(TryOption<A> a) => default(MOptionAsync<TryOption<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOption<B>> Select< A, B>(this OptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<TryOption<B>>).ReturnAsync(_ => default(MTryOption<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<TryOption<A>> ma) =>
            default(TransAsyncSync<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOption<B>> BindT< A, B>(this OptionAsync<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            default(TransAsyncSync<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Bind<MOptionAsync<TryOption<B>>, OptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<TryOption<B>> MapT< A, B>(this OptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Map<MOptionAsync<TryOption<B>>, OptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<TryOption<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<TryOption<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<TryOption<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<TryOption<A>>, OptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> FilterT< A>(this OptionAsync<TryOption<A>> ma, Func<A, bool> f)
        {
            OptionAsync<TryOption<A>> Do(TryOption<A> a) => default(MOptionAsync<TryOption<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> PlusT<NUM,  A>(this OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> SubtractT<NUM,  A>(this OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> ProductT<NUM,  A>(this OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> DivideT<NUM,  A>(this OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<TryOption<A>> AppendT<SEMI,  A>(this OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<TryOption<A>> x, OptionAsync<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<TryOption<A>> fa) =>
            default(ApplOptionAsync< TryOption<A>, TryOption<B>>).Apply(
                default(MOptionAsync< Func<TryOption<A>, TryOption<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryOption<A>, TryOption<B>>>((TryOption<A> a) => 
                        default(ApplTryOption< A, B>).Apply(
                            default(MTryOption< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<TryOption<A>> fa, OptionAsync<TryOption<B>> fb) =>
            default(ApplOptionAsync< TryOption<A>, TryOption<B>, TryOption<C>>).Apply(
                default(MOptionAsync< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>((TryOption<A> a) =>
                        (TryOption<B> b) =>
                            default(ApplTryOption< A, B, C>).Apply(
                                default(MTryOption< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, TryOption<C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, TryOption<A>> ma,
            Func<A, EitherAsync<L, TryOption<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, TryOption<A>> Where<L, A>(this EitherAsync<L, TryOption<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, TryOption<A>> Do(TryOption<A> a) => default(MEitherAsync<L, TryOption<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, TryOption<B>> Select<L, A, B>(this EitherAsync<L, TryOption<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, TryOption<B>>).ReturnAsync(_ => default(MTryOption<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, TryOption<A>>, EitherAsync<L, TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, TryOption<A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, TryOption<A>>, EitherAsync<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, TryOption<B>> BindT<L, A, B>(this EitherAsync<L, TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, TryOption<A>>, EitherAsync<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Bind<MEitherAsync<L, TryOption<B>>, EitherAsync<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, TryOption<B>> MapT<L, A, B>(this EitherAsync<L, TryOption<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, TryOption<A>>, EitherAsync<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Map<MEitherAsync<L, TryOption<B>>, EitherAsync<L, TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, TryOption<A>>, EitherAsync<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, TryOption<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, TryOption<A>>, EitherAsync<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, TryOption<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, TryOption<A>>, EitherAsync<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, TryOption<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, TryOption<A>>, EitherAsync<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, TryOption<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, TryOption<A>>, EitherAsync<L, TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, TryOption<A>> FilterT<L, A>(this EitherAsync<L, TryOption<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, TryOption<A>> Do(TryOption<A> a) => default(MEitherAsync<L, TryOption<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, TryOption<A>> PlusT<NUM, L, A>(this EitherAsync<L, TryOption<A>> x, EitherAsync<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, TryOption<A>> SubtractT<NUM, L, A>(this EitherAsync<L, TryOption<A>> x, EitherAsync<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, TryOption<A>> ProductT<NUM, L, A>(this EitherAsync<L, TryOption<A>> x, EitherAsync<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, TryOption<A>> DivideT<NUM, L, A>(this EitherAsync<L, TryOption<A>> x, EitherAsync<L, TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, TryOption<A>> AppendT<SEMI, L, A>(this EitherAsync<L, TryOption<A>> x, EitherAsync<L, TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, TryOption<A>> x, EitherAsync<L, TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, TryOption<A>> x, EitherAsync<L, TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, TryOption<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, TryOption<A>> fa) =>
            default(ApplEitherAsync<L, TryOption<A>, TryOption<B>>).Apply(
                default(MEitherAsync<L, Func<TryOption<A>, TryOption<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryOption<A>, TryOption<B>>>((TryOption<A> a) => 
                        default(ApplTryOption< A, B>).Apply(
                            default(MTryOption< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, TryOption<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, TryOption<A>> fa, EitherAsync<L, TryOption<B>> fb) =>
            default(ApplEitherAsync<L, TryOption<A>, TryOption<B>, TryOption<C>>).Apply(
                default(MEitherAsync<L, Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>((TryOption<A> a) =>
                        (TryOption<B> b) =>
                            default(ApplTryOption< A, B, C>).Apply(
                                default(MTryOption< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<TryOption<C>> SelectMany< A, B, C>(
            this Task<TryOption<A>> ma,
            Func<A, Task<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryOption<A>> Where< A>(this Task<TryOption<A>> ma, Func<A, bool> f)
        {
            Task<TryOption<A>> Do(TryOption<A> a) => default(MTask<TryOption<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOption<B>> Select< A, B>(this Task<TryOption<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<TryOption<B>>).ReturnAsync(_ => default(MTryOption<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<TryOption<A>> ma) =>
            default(TransAsyncSync<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOption<B>> BindT< A, B>(this Task<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            default(TransAsyncSync<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Bind<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<TryOption<B>> MapT< A, B>(this Task<TryOption<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Map<MTask<TryOption<B>>, Task<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<TryOption<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<TryOption<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<TryOption<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<TryOption<A>>, Task<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<TryOption<A>> FilterT< A>(this Task<TryOption<A>> ma, Func<A, bool> f)
        {
            Task<TryOption<A>> Do(TryOption<A> a) => default(MTask<TryOption<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<TryOption<A>> PlusT<NUM,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<TryOption<A>> SubtractT<NUM,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<TryOption<A>> ProductT<NUM,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<TryOption<A>> DivideT<NUM,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<TryOption<A>> AppendT<SEMI,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<TryOption<A>> x, Task<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, Task<TryOption<A>> fa) =>
            default(ApplTask< TryOption<A>, TryOption<B>>).Apply(
                default(MTask< Func<TryOption<A>, TryOption<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryOption<A>, TryOption<B>>>((TryOption<A> a) => 
                        default(ApplTryOption< A, B>).Apply(
                            default(MTryOption< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<TryOption<A>> fa, Task<TryOption<B>> fb) =>
            default(ApplTask< TryOption<A>, TryOption<B>, TryOption<C>>).Apply(
                default(MTask< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>((TryOption<A> a) =>
                        (TryOption<B> b) =>
                            default(ApplTryOption< A, B, C>).Apply(
                                default(MTryOption< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<TryOption<C>> SelectMany< A, B, C>(
            this TryAsync<TryOption<A>> ma,
            Func<A, TryAsync<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryOption<A>> Where< A>(this TryAsync<TryOption<A>> ma, Func<A, bool> f)
        {
            TryAsync<TryOption<A>> Do(TryOption<A> a) => default(MTryAsync<TryOption<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOption<B>> Select< A, B>(this TryAsync<TryOption<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<TryOption<B>>).ReturnAsync(_ => default(MTryOption<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<TryOption<A>> ma) =>
            default(TransAsyncSync<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOption<B>> BindT< A, B>(this TryAsync<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            default(TransAsyncSync<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Bind<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<TryOption<B>> MapT< A, B>(this TryAsync<TryOption<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Map<MTryAsync<TryOption<B>>, TryAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<TryOption<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<TryOption<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<TryOption<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<TryOption<A>>, TryAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<TryOption<A>> FilterT< A>(this TryAsync<TryOption<A>> ma, Func<A, bool> f)
        {
            TryAsync<TryOption<A>> Do(TryOption<A> a) => default(MTryAsync<TryOption<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<TryOption<A>> PlusT<NUM,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<TryOption<A>> SubtractT<NUM,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<TryOption<A>> ProductT<NUM,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<TryOption<A>> DivideT<NUM,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<TryOption<A>> AppendT<SEMI,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<TryOption<A>> x, TryAsync<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<TryOption<A>> fa) =>
            default(ApplTryAsync< TryOption<A>, TryOption<B>>).Apply(
                default(MTryAsync< Func<TryOption<A>, TryOption<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryOption<A>, TryOption<B>>>((TryOption<A> a) => 
                        default(ApplTryOption< A, B>).Apply(
                            default(MTryOption< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<TryOption<A>> fa, TryAsync<TryOption<B>> fb) =>
            default(ApplTryAsync< TryOption<A>, TryOption<B>, TryOption<C>>).Apply(
                default(MTryAsync< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>((TryOption<A> a) =>
                        (TryOption<B> b) =>
                            default(ApplTryOption< A, B, C>).Apply(
                                default(MTryOption< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<TryOption<C>> SelectMany< A, B, C>(
            this TryOptionAsync<TryOption<A>> ma,
            Func<A, TryOptionAsync<TryOption<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MTryOption<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> Where< A>(this TryOptionAsync<TryOption<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<TryOption<A>> Do(TryOption<A> a) => default(MTryOptionAsync<TryOption<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> Select< A, B>(this TryOptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<TryOption<B>>).ReturnAsync(_ => default(MTryOption<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<TryOption<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<TryOption<A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> BindT< A, B>(this TryOptionAsync<TryOption<A>> ma, Func<A, TryOption<B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Bind<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> MapT< A, B>(this TryOptionAsync<TryOption<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Map<MTryOptionAsync<TryOption<B>>, TryOptionAsync<TryOption<B>>, MTryOption<B>, TryOption<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<TryOption<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<TryOption<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<TryOption<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<TryOption<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<TryOption<A>>, TryOptionAsync<TryOption<A>>, MTryOption<A>, TryOption<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> FilterT< A>(this TryOptionAsync<TryOption<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<TryOption<A>> Do(TryOption<A> a) => default(MTryOptionAsync<TryOption<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> PlusT<NUM,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> SubtractT<NUM,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> ProductT<NUM,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> DivideT<NUM,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<A>> AppendT<SEMI,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<TryOption<A>> x, TryOptionAsync<TryOption<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<TryOption<A>> fa) =>
            default(ApplTryOptionAsync< TryOption<A>, TryOption<B>>).Apply(
                default(MTryOptionAsync< Func<TryOption<A>, TryOption<B>>>).ReturnAsync(
                    Task.FromResult<Func<TryOption<A>, TryOption<B>>>((TryOption<A> a) => 
                        default(ApplTryOption< A, B>).Apply(
                            default(MTryOption< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;TryOption&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;TryOption&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<TryOption<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<TryOption<A>> fa, TryOptionAsync<TryOption<B>> fb) =>
            default(ApplTryOptionAsync< TryOption<A>, TryOption<B>, TryOption<C>>).Apply(
                default(MTryOptionAsync< Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>).ReturnAsync(
                    Task.FromResult<Func<TryOption<A>, Func<TryOption<B>, TryOption<C>>>>((TryOption<A> a) =>
                        (TryOption<B> b) =>
                            default(ApplTryOption< A, B, C>).Apply(
                                default(MTryOption< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for IEnumerable, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class IEnumerableT_AsyncSync_Extensions
    {
        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<IEnumerable<A>> ma) =>
            default(TransAsyncSync<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<B>> BindT< A, B>(this OptionAsync<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            default(TransAsyncSync<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Bind<MOptionAsync<IEnumerable<B>>, OptionAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<B>> MapT< A, B>(this OptionAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Map<MOptionAsync<IEnumerable<B>>, OptionAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<IEnumerable<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<IEnumerable<A>>, OptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> FilterT< A>(this OptionAsync<IEnumerable<A>> ma, Func<A, bool> f)
        {
            OptionAsync<IEnumerable<A>> Do(IEnumerable<A> a) => default(MOptionAsync<IEnumerable<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> PlusT<NUM,  A>(this OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> SubtractT<NUM,  A>(this OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> ProductT<NUM,  A>(this OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> DivideT<NUM,  A>(this OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<A>> AppendT<SEMI,  A>(this OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<IEnumerable<A>> x, OptionAsync<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<IEnumerable<A>> fa) =>
            default(ApplOptionAsync< IEnumerable<A>, IEnumerable<B>>).Apply(
                default(MOptionAsync< Func<IEnumerable<A>, IEnumerable<B>>>).ReturnAsync(
                    Task.FromResult<Func<IEnumerable<A>, IEnumerable<B>>>((IEnumerable<A> a) => 
                        default(ApplEnumerable< A, B>).Apply(
                            default(MEnumerable< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<IEnumerable<A>> fa, OptionAsync<IEnumerable<B>> fb) =>
            default(ApplOptionAsync< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>).Apply(
                default(MOptionAsync< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>).ReturnAsync(
                    Task.FromResult<Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>((IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            default(ApplEnumerable< A, B, C>).Apply(
                                default(MEnumerable< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, IEnumerable<A>>, EitherAsync<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, IEnumerable<A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, IEnumerable<A>>, EitherAsync<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, IEnumerable<B>> BindT<L, A, B>(this EitherAsync<L, IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, IEnumerable<A>>, EitherAsync<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Bind<MEitherAsync<L, IEnumerable<B>>, EitherAsync<L, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, IEnumerable<B>> MapT<L, A, B>(this EitherAsync<L, IEnumerable<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, IEnumerable<A>>, EitherAsync<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Map<MEitherAsync<L, IEnumerable<B>>, EitherAsync<L, IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, IEnumerable<A>>, EitherAsync<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, IEnumerable<A>>, EitherAsync<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, IEnumerable<A>>, EitherAsync<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, IEnumerable<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, IEnumerable<A>>, EitherAsync<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, IEnumerable<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, IEnumerable<A>>, EitherAsync<L, IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, IEnumerable<A>> FilterT<L, A>(this EitherAsync<L, IEnumerable<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, IEnumerable<A>> Do(IEnumerable<A> a) => default(MEitherAsync<L, IEnumerable<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, IEnumerable<A>> PlusT<NUM, L, A>(this EitherAsync<L, IEnumerable<A>> x, EitherAsync<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, IEnumerable<A>> SubtractT<NUM, L, A>(this EitherAsync<L, IEnumerable<A>> x, EitherAsync<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, IEnumerable<A>> ProductT<NUM, L, A>(this EitherAsync<L, IEnumerable<A>> x, EitherAsync<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, IEnumerable<A>> DivideT<NUM, L, A>(this EitherAsync<L, IEnumerable<A>> x, EitherAsync<L, IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, IEnumerable<A>> AppendT<SEMI, L, A>(this EitherAsync<L, IEnumerable<A>> x, EitherAsync<L, IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, IEnumerable<A>> x, EitherAsync<L, IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, IEnumerable<A>> x, EitherAsync<L, IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, IEnumerable<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, IEnumerable<A>> fa) =>
            default(ApplEitherAsync<L, IEnumerable<A>, IEnumerable<B>>).Apply(
                default(MEitherAsync<L, Func<IEnumerable<A>, IEnumerable<B>>>).ReturnAsync(
                    Task.FromResult<Func<IEnumerable<A>, IEnumerable<B>>>((IEnumerable<A> a) => 
                        default(ApplEnumerable< A, B>).Apply(
                            default(MEnumerable< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, IEnumerable<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, IEnumerable<A>> fa, EitherAsync<L, IEnumerable<B>> fb) =>
            default(ApplEitherAsync<L, IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>).Apply(
                default(MEitherAsync<L, Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>).ReturnAsync(
                    Task.FromResult<Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>((IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            default(ApplEnumerable< A, B, C>).Apply(
                                default(MEnumerable< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<IEnumerable<A>> ma) =>
            default(TransAsyncSync<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<IEnumerable<B>> BindT< A, B>(this Task<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            default(TransAsyncSync<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Bind<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<IEnumerable<B>> MapT< A, B>(this Task<IEnumerable<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Map<MTask<IEnumerable<B>>, Task<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<IEnumerable<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<IEnumerable<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<IEnumerable<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<IEnumerable<A>>, Task<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<IEnumerable<A>> FilterT< A>(this Task<IEnumerable<A>> ma, Func<A, bool> f)
        {
            Task<IEnumerable<A>> Do(IEnumerable<A> a) => default(MTask<IEnumerable<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<IEnumerable<A>> PlusT<NUM,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<IEnumerable<A>> SubtractT<NUM,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<IEnumerable<A>> ProductT<NUM,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<IEnumerable<A>> DivideT<NUM,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<IEnumerable<A>> AppendT<SEMI,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<IEnumerable<A>> x, Task<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, Task<IEnumerable<A>> fa) =>
            default(ApplTask< IEnumerable<A>, IEnumerable<B>>).Apply(
                default(MTask< Func<IEnumerable<A>, IEnumerable<B>>>).ReturnAsync(
                    Task.FromResult<Func<IEnumerable<A>, IEnumerable<B>>>((IEnumerable<A> a) => 
                        default(ApplEnumerable< A, B>).Apply(
                            default(MEnumerable< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<IEnumerable<A>> fa, Task<IEnumerable<B>> fb) =>
            default(ApplTask< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>).Apply(
                default(MTask< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>).ReturnAsync(
                    Task.FromResult<Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>((IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            default(ApplEnumerable< A, B, C>).Apply(
                                default(MEnumerable< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<IEnumerable<A>> ma) =>
            default(TransAsyncSync<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> BindT< A, B>(this TryAsync<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            default(TransAsyncSync<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Bind<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> MapT< A, B>(this TryAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Map<MTryAsync<IEnumerable<B>>, TryAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<IEnumerable<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<IEnumerable<A>>, TryAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> FilterT< A>(this TryAsync<IEnumerable<A>> ma, Func<A, bool> f)
        {
            TryAsync<IEnumerable<A>> Do(IEnumerable<A> a) => default(MTryAsync<IEnumerable<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> PlusT<NUM,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> SubtractT<NUM,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> ProductT<NUM,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> DivideT<NUM,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<IEnumerable<A>> AppendT<SEMI,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<IEnumerable<A>> x, TryAsync<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<IEnumerable<A>> fa) =>
            default(ApplTryAsync< IEnumerable<A>, IEnumerable<B>>).Apply(
                default(MTryAsync< Func<IEnumerable<A>, IEnumerable<B>>>).ReturnAsync(
                    Task.FromResult<Func<IEnumerable<A>, IEnumerable<B>>>((IEnumerable<A> a) => 
                        default(ApplEnumerable< A, B>).Apply(
                            default(MEnumerable< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<IEnumerable<A>> fa, TryAsync<IEnumerable<B>> fb) =>
            default(ApplTryAsync< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>).Apply(
                default(MTryAsync< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>).ReturnAsync(
                    Task.FromResult<Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>((IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            default(ApplEnumerable< A, B, C>).Apply(
                                default(MEnumerable< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<IEnumerable<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<IEnumerable<A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> BindT< A, B>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, IEnumerable<B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Bind<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> MapT< A, B>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Map<MTryOptionAsync<IEnumerable<B>>, TryOptionAsync<IEnumerable<B>>, MEnumerable<B>, IEnumerable<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<IEnumerable<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<IEnumerable<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<IEnumerable<A>>, TryOptionAsync<IEnumerable<A>>, MEnumerable<A>, IEnumerable<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> FilterT< A>(this TryOptionAsync<IEnumerable<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<IEnumerable<A>> Do(IEnumerable<A> a) => default(MTryOptionAsync<IEnumerable<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> PlusT<NUM,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> SubtractT<NUM,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> ProductT<NUM,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> DivideT<NUM,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<A>> AppendT<SEMI,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<IEnumerable<A>> x, TryOptionAsync<IEnumerable<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<IEnumerable<A>> fa) =>
            default(ApplTryOptionAsync< IEnumerable<A>, IEnumerable<B>>).Apply(
                default(MTryOptionAsync< Func<IEnumerable<A>, IEnumerable<B>>>).ReturnAsync(
                    Task.FromResult<Func<IEnumerable<A>, IEnumerable<B>>>((IEnumerable<A> a) => 
                        default(ApplEnumerable< A, B>).Apply(
                            default(MEnumerable< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;IEnumerable&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;IEnumerable&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<IEnumerable<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<IEnumerable<A>> fa, TryOptionAsync<IEnumerable<B>> fb) =>
            default(ApplTryOptionAsync< IEnumerable<A>, IEnumerable<B>, IEnumerable<C>>).Apply(
                default(MTryOptionAsync< Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>).ReturnAsync(
                    Task.FromResult<Func<IEnumerable<A>, Func<IEnumerable<B>, IEnumerable<C>>>>((IEnumerable<A> a) =>
                        (IEnumerable<B> b) =>
                            default(ApplEnumerable< A, B, C>).Apply(
                                default(MEnumerable< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for Seq, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class SeqT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Seq<C>> SelectMany< A, B, C>(
            this OptionAsync<Seq<A>> ma,
            Func<A, OptionAsync<Seq<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Seq<A>> Where< A>(this OptionAsync<Seq<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Seq<A>> Do(Seq<A> a) => default(MOptionAsync<Seq<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Seq<B>> Select< A, B>(this OptionAsync<Seq<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<Seq<B>>).ReturnAsync(_ => default(MSeq<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<Seq<A>>, OptionAsync<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<Seq<A>> ma) =>
            default(TransAsyncSync<MOptionAsync<Seq<A>>, OptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Seq<B>> BindT< A, B>(this OptionAsync<Seq<A>> ma, Func<A, Seq<B>> f) =>
            default(TransAsyncSync<MOptionAsync<Seq<A>>, OptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Bind<MOptionAsync<Seq<B>>, OptionAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Seq<B>> MapT< A, B>(this OptionAsync<Seq<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<Seq<A>>, OptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Map<MOptionAsync<Seq<B>>, OptionAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<Seq<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Seq<A>>, OptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<Seq<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Seq<A>>, OptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<Seq<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Seq<A>>, OptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<Seq<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Seq<A>>, OptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<Seq<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<Seq<A>>, OptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Seq<A>> FilterT< A>(this OptionAsync<Seq<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Seq<A>> Do(Seq<A> a) => default(MOptionAsync<Seq<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Seq<A>> PlusT<NUM,  A>(this OptionAsync<Seq<A>> x, OptionAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Seq<A>> SubtractT<NUM,  A>(this OptionAsync<Seq<A>> x, OptionAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Seq<A>> ProductT<NUM,  A>(this OptionAsync<Seq<A>> x, OptionAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Seq<A>> DivideT<NUM,  A>(this OptionAsync<Seq<A>> x, OptionAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Seq<A>> AppendT<SEMI,  A>(this OptionAsync<Seq<A>> x, OptionAsync<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<Seq<A>> x, OptionAsync<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<Seq<A>> x, OptionAsync<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<Seq<A>> fa) =>
            default(ApplOptionAsync< Seq<A>, Seq<B>>).Apply(
                default(MOptionAsync< Func<Seq<A>, Seq<B>>>).ReturnAsync(
                    Task.FromResult<Func<Seq<A>, Seq<B>>>((Seq<A> a) => 
                        default(ApplSeq< A, B>).Apply(
                            default(MSeq< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<Seq<A>> fa, OptionAsync<Seq<B>> fb) =>
            default(ApplOptionAsync< Seq<A>, Seq<B>, Seq<C>>).Apply(
                default(MOptionAsync< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Seq<A>, Func<Seq<B>, Seq<C>>>>((Seq<A> a) =>
                        (Seq<B> b) =>
                            default(ApplSeq< A, B, C>).Apply(
                                default(MSeq< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, Seq<C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, Seq<A>> ma,
            Func<A, EitherAsync<L, Seq<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Seq<A>> Where<L, A>(this EitherAsync<L, Seq<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Seq<A>> Do(Seq<A> a) => default(MEitherAsync<L, Seq<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Seq<B>> Select<L, A, B>(this EitherAsync<L, Seq<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, Seq<B>>).ReturnAsync(_ => default(MSeq<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, Seq<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, Seq<A>>, EitherAsync<L, Seq<A>>, MSeq<A>, Seq<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, Seq<A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, Seq<A>>, EitherAsync<L, Seq<A>>, MSeq<A>, Seq<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Seq<B>> BindT<L, A, B>(this EitherAsync<L, Seq<A>> ma, Func<A, Seq<B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, Seq<A>>, EitherAsync<L, Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Bind<MEitherAsync<L, Seq<B>>, EitherAsync<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Seq<B>> MapT<L, A, B>(this EitherAsync<L, Seq<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, Seq<A>>, EitherAsync<L, Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Map<MEitherAsync<L, Seq<B>>, EitherAsync<L, Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, Seq<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Seq<A>>, EitherAsync<L, Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, Seq<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Seq<A>>, EitherAsync<L, Seq<A>>, MSeq<A>, Seq<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, Seq<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Seq<A>>, EitherAsync<L, Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, Seq<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Seq<A>>, EitherAsync<L, Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, Seq<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, Seq<A>>, EitherAsync<L, Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Seq<A>> FilterT<L, A>(this EitherAsync<L, Seq<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Seq<A>> Do(Seq<A> a) => default(MEitherAsync<L, Seq<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, Seq<A>> PlusT<NUM, L, A>(this EitherAsync<L, Seq<A>> x, EitherAsync<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, Seq<A>> SubtractT<NUM, L, A>(this EitherAsync<L, Seq<A>> x, EitherAsync<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, Seq<A>> ProductT<NUM, L, A>(this EitherAsync<L, Seq<A>> x, EitherAsync<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, Seq<A>> DivideT<NUM, L, A>(this EitherAsync<L, Seq<A>> x, EitherAsync<L, Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, Seq<A>> AppendT<SEMI, L, A>(this EitherAsync<L, Seq<A>> x, EitherAsync<L, Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, Seq<A>> x, EitherAsync<L, Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, Seq<A>> x, EitherAsync<L, Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Seq&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, Seq<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, Seq<A>> fa) =>
            default(ApplEitherAsync<L, Seq<A>, Seq<B>>).Apply(
                default(MEitherAsync<L, Func<Seq<A>, Seq<B>>>).ReturnAsync(
                    Task.FromResult<Func<Seq<A>, Seq<B>>>((Seq<A> a) => 
                        default(ApplSeq< A, B>).Apply(
                            default(MSeq< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, Seq&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, Seq<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, Seq<A>> fa, EitherAsync<L, Seq<B>> fb) =>
            default(ApplEitherAsync<L, Seq<A>, Seq<B>, Seq<C>>).Apply(
                default(MEitherAsync<L, Func<Seq<A>, Func<Seq<B>, Seq<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Seq<A>, Func<Seq<B>, Seq<C>>>>((Seq<A> a) =>
                        (Seq<B> b) =>
                            default(ApplSeq< A, B, C>).Apply(
                                default(MSeq< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Seq<C>> SelectMany< A, B, C>(
            this Task<Seq<A>> ma,
            Func<A, Task<Seq<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Seq<A>> Where< A>(this Task<Seq<A>> ma, Func<A, bool> f)
        {
            Task<Seq<A>> Do(Seq<A> a) => default(MTask<Seq<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Seq<B>> Select< A, B>(this Task<Seq<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<Seq<B>>).ReturnAsync(_ => default(MSeq<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<Seq<A>>, Task<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<Seq<A>> ma) =>
            default(TransAsyncSync<MTask<Seq<A>>, Task<Seq<A>>, MSeq<A>, Seq<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Seq<B>> BindT< A, B>(this Task<Seq<A>> ma, Func<A, Seq<B>> f) =>
            default(TransAsyncSync<MTask<Seq<A>>, Task<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Bind<MTask<Seq<B>>, Task<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Seq<B>> MapT< A, B>(this Task<Seq<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<Seq<A>>, Task<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Map<MTask<Seq<B>>, Task<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<Seq<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Seq<A>>, Task<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<Seq<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Seq<A>>, Task<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<Seq<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Seq<A>>, Task<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<Seq<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Seq<A>>, Task<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<Seq<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<Seq<A>>, Task<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Seq<A>> FilterT< A>(this Task<Seq<A>> ma, Func<A, bool> f)
        {
            Task<Seq<A>> Do(Seq<A> a) => default(MTask<Seq<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Seq<A>> PlusT<NUM,  A>(this Task<Seq<A>> x, Task<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Seq<A>> SubtractT<NUM,  A>(this Task<Seq<A>> x, Task<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Seq<A>> ProductT<NUM,  A>(this Task<Seq<A>> x, Task<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Seq<A>> DivideT<NUM,  A>(this Task<Seq<A>> x, Task<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Seq<A>> AppendT<SEMI,  A>(this Task<Seq<A>> x, Task<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<Seq<A>> x, Task<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<Seq<A>> x, Task<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Seq<A>> fa) =>
            default(ApplTask< Seq<A>, Seq<B>>).Apply(
                default(MTask< Func<Seq<A>, Seq<B>>>).ReturnAsync(
                    Task.FromResult<Func<Seq<A>, Seq<B>>>((Seq<A> a) => 
                        default(ApplSeq< A, B>).Apply(
                            default(MSeq< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Seq<A>> fa, Task<Seq<B>> fb) =>
            default(ApplTask< Seq<A>, Seq<B>, Seq<C>>).Apply(
                default(MTask< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Seq<A>, Func<Seq<B>, Seq<C>>>>((Seq<A> a) =>
                        (Seq<B> b) =>
                            default(ApplSeq< A, B, C>).Apply(
                                default(MSeq< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Seq<C>> SelectMany< A, B, C>(
            this TryAsync<Seq<A>> ma,
            Func<A, TryAsync<Seq<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Seq<A>> Where< A>(this TryAsync<Seq<A>> ma, Func<A, bool> f)
        {
            TryAsync<Seq<A>> Do(Seq<A> a) => default(MTryAsync<Seq<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Seq<B>> Select< A, B>(this TryAsync<Seq<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<Seq<B>>).ReturnAsync(_ => default(MSeq<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<Seq<A>>, TryAsync<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<Seq<A>> ma) =>
            default(TransAsyncSync<MTryAsync<Seq<A>>, TryAsync<Seq<A>>, MSeq<A>, Seq<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Seq<B>> BindT< A, B>(this TryAsync<Seq<A>> ma, Func<A, Seq<B>> f) =>
            default(TransAsyncSync<MTryAsync<Seq<A>>, TryAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Bind<MTryAsync<Seq<B>>, TryAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Seq<B>> MapT< A, B>(this TryAsync<Seq<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<Seq<A>>, TryAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Map<MTryAsync<Seq<B>>, TryAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<Seq<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Seq<A>>, TryAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<Seq<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Seq<A>>, TryAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<Seq<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Seq<A>>, TryAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<Seq<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Seq<A>>, TryAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<Seq<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<Seq<A>>, TryAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Seq<A>> FilterT< A>(this TryAsync<Seq<A>> ma, Func<A, bool> f)
        {
            TryAsync<Seq<A>> Do(Seq<A> a) => default(MTryAsync<Seq<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Seq<A>> PlusT<NUM,  A>(this TryAsync<Seq<A>> x, TryAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Seq<A>> SubtractT<NUM,  A>(this TryAsync<Seq<A>> x, TryAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Seq<A>> ProductT<NUM,  A>(this TryAsync<Seq<A>> x, TryAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Seq<A>> DivideT<NUM,  A>(this TryAsync<Seq<A>> x, TryAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Seq<A>> AppendT<SEMI,  A>(this TryAsync<Seq<A>> x, TryAsync<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<Seq<A>> x, TryAsync<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<Seq<A>> x, TryAsync<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Seq<A>> fa) =>
            default(ApplTryAsync< Seq<A>, Seq<B>>).Apply(
                default(MTryAsync< Func<Seq<A>, Seq<B>>>).ReturnAsync(
                    Task.FromResult<Func<Seq<A>, Seq<B>>>((Seq<A> a) => 
                        default(ApplSeq< A, B>).Apply(
                            default(MSeq< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Seq<A>> fa, TryAsync<Seq<B>> fb) =>
            default(ApplTryAsync< Seq<A>, Seq<B>, Seq<C>>).Apply(
                default(MTryAsync< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Seq<A>, Func<Seq<B>, Seq<C>>>>((Seq<A> a) =>
                        (Seq<B> b) =>
                            default(ApplSeq< A, B, C>).Apply(
                                default(MSeq< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Seq<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Seq<A>> ma,
            Func<A, TryOptionAsync<Seq<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MSeq<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Seq<A>> Where< A>(this TryOptionAsync<Seq<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Seq<A>> Do(Seq<A> a) => default(MTryOptionAsync<Seq<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Seq<B>> Select< A, B>(this TryOptionAsync<Seq<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<Seq<B>>).ReturnAsync(_ => default(MSeq<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<Seq<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<Seq<A>>, TryOptionAsync<Seq<A>>, MSeq<A>, Seq<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;Seq&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<Seq<A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<Seq<A>>, TryOptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Seq<B>> BindT< A, B>(this TryOptionAsync<Seq<A>> ma, Func<A, Seq<B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<Seq<A>>, TryOptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Bind<MTryOptionAsync<Seq<B>>, TryOptionAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Seq<B>> MapT< A, B>(this TryOptionAsync<Seq<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<Seq<A>>, TryOptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Map<MTryOptionAsync<Seq<B>>, TryOptionAsync<Seq<B>>, MSeq<B>, Seq<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<Seq<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Seq<A>>, TryOptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<Seq<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Seq<A>>, TryOptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<Seq<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Seq<A>>, TryOptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<Seq<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Seq<A>>, TryOptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;Seq&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<Seq<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<Seq<A>>, TryOptionAsync<Seq<A>>, MSeq<A>, Seq<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Seq&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Seq<A>> FilterT< A>(this TryOptionAsync<Seq<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Seq<A>> Do(Seq<A> a) => default(MTryOptionAsync<Seq<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Seq<A>> PlusT<NUM,  A>(this TryOptionAsync<Seq<A>> x, TryOptionAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Seq<A>> SubtractT<NUM,  A>(this TryOptionAsync<Seq<A>> x, TryOptionAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Seq<A>> ProductT<NUM,  A>(this TryOptionAsync<Seq<A>> x, TryOptionAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Seq<A>> DivideT<NUM,  A>(this TryOptionAsync<Seq<A>> x, TryOptionAsync<Seq<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Seq<A>> AppendT<SEMI,  A>(this TryOptionAsync<Seq<A>> x, TryOptionAsync<Seq<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<Seq<A>> x, TryOptionAsync<Seq<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<Seq<A>> x, TryOptionAsync<Seq<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Seq<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Seq<A>> fa) =>
            default(ApplTryOptionAsync< Seq<A>, Seq<B>>).Apply(
                default(MTryOptionAsync< Func<Seq<A>, Seq<B>>>).ReturnAsync(
                    Task.FromResult<Func<Seq<A>, Seq<B>>>((Seq<A> a) => 
                        default(ApplSeq< A, B>).Apply(
                            default(MSeq< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Seq&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;Seq&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Seq&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Seq<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Seq<A>> fa, TryOptionAsync<Seq<B>> fb) =>
            default(ApplTryOptionAsync< Seq<A>, Seq<B>, Seq<C>>).Apply(
                default(MTryOptionAsync< Func<Seq<A>, Func<Seq<B>, Seq<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Seq<A>, Func<Seq<B>, Seq<C>>>>((Seq<A> a) =>
                        (Seq<B> b) =>
                            default(ApplSeq< A, B, C>).Apply(
                                default(MSeq< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for Set, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class SetT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Set<C>> SelectMany< A, B, C>(
            this OptionAsync<Set<A>> ma,
            Func<A, OptionAsync<Set<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Set<A>> Where< A>(this OptionAsync<Set<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Set<A>> Do(Set<A> a) => default(MOptionAsync<Set<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Set<B>> Select< A, B>(this OptionAsync<Set<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<Set<B>>).ReturnAsync(_ => default(MSet<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this OptionAsync<Set<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this OptionAsync<Set<A>> ma) =>
            default(TransAsyncSync<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Set<B>> BindT< A, B>(this OptionAsync<Set<A>> ma, Func<A, Set<B>> f) =>
            default(TransAsyncSync<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Bind<MOptionAsync<Set<B>>, OptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Set<B>> MapT< A, B>(this OptionAsync<Set<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Map<MOptionAsync<Set<B>>, OptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this OptionAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this OptionAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this OptionAsync<Set<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this OptionAsync<Set<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this OptionAsync<Set<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<Set<A>>, OptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Set<A>> FilterT< A>(this OptionAsync<Set<A>> ma, Func<A, bool> f)
        {
            OptionAsync<Set<A>> Do(Set<A> a) => default(MOptionAsync<Set<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Set<A>> PlusT<NUM,  A>(this OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Set<A>> SubtractT<NUM,  A>(this OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Set<A>> ProductT<NUM,  A>(this OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Set<A>> DivideT<NUM,  A>(this OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Set<A>> AppendT<SEMI,  A>(this OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this OptionAsync<Set<A>> x, OptionAsync<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Set<B>> ApplyT< A, B>(this Func<A, B> fab, OptionAsync<Set<A>> fa) =>
            default(ApplOptionAsync< Set<A>, Set<B>>).Apply(
                default(MOptionAsync< Func<Set<A>, Set<B>>>).ReturnAsync(
                    Task.FromResult<Func<Set<A>, Set<B>>>((Set<A> a) => 
                        default(ApplSet< A, B>).Apply(
                            default(MSet< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, OptionAsync<Set<A>> fa, OptionAsync<Set<B>> fb) =>
            default(ApplOptionAsync< Set<A>, Set<B>, Set<C>>).Apply(
                default(MOptionAsync< Func<Set<A>, Func<Set<B>, Set<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Set<A>, Func<Set<B>, Set<C>>>>((Set<A> a) =>
                        (Set<B> b) =>
                            default(ApplSet< A, B, C>).Apply(
                                default(MSet< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, Set<C>> SelectMany<L, A, B, C>(
            this EitherAsync<L, Set<A>> ma,
            Func<A, EitherAsync<L, Set<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Set<A>> Where<L, A>(this EitherAsync<L, Set<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Set<A>> Do(Set<A> a) => default(MEitherAsync<L, Set<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Set<B>> Select<L, A, B>(this EitherAsync<L, Set<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, Set<B>>).ReturnAsync(_ => default(MSet<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, A>(this EitherAsync<L, Set<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, Set<A>>, EitherAsync<L, Set<A>>, MSet<A>, Set<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, A>(this EitherAsync<L, Set<A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, Set<A>>, EitherAsync<L, Set<A>>, MSet<A>, Set<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Set<B>> BindT<L, A, B>(this EitherAsync<L, Set<A>> ma, Func<A, Set<B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, Set<A>>, EitherAsync<L, Set<A>>, MSet<A>, Set<A>, A>)
                .Bind<MEitherAsync<L, Set<B>>, EitherAsync<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Set<B>> MapT<L, A, B>(this EitherAsync<L, Set<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, Set<A>>, EitherAsync<L, Set<A>>, MSet<A>, Set<A>, A>)
                .Map<MEitherAsync<L, Set<B>>, EitherAsync<L, Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, A>(this EitherAsync<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Set<A>>, EitherAsync<L, Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, A>(this EitherAsync<L, Set<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Set<A>>, EitherAsync<L, Set<A>>, MSet<A>, Set<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, A>(this EitherAsync<L, Set<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Set<A>>, EitherAsync<L, Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, A>(this EitherAsync<L, Set<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Set<A>>, EitherAsync<L, Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, A>(this EitherAsync<L, Set<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, Set<A>>, EitherAsync<L, Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Set<A>> FilterT<L, A>(this EitherAsync<L, Set<A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Set<A>> Do(Set<A> a) => default(MEitherAsync<L, Set<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, Set<A>> PlusT<NUM, L, A>(this EitherAsync<L, Set<A>> x, EitherAsync<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, Set<A>> SubtractT<NUM, L, A>(this EitherAsync<L, Set<A>> x, EitherAsync<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, Set<A>> ProductT<NUM, L, A>(this EitherAsync<L, Set<A>> x, EitherAsync<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, Set<A>> DivideT<NUM, L, A>(this EitherAsync<L, Set<A>> x, EitherAsync<L, Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, Set<A>> AppendT<SEMI, L, A>(this EitherAsync<L, Set<A>> x, EitherAsync<L, Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, A>(this EitherAsync<L, Set<A>> x, EitherAsync<L, Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, A>(this EitherAsync<L, Set<A>> x, EitherAsync<L, Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Set&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, Set<B>> ApplyT<L, A, B>(this Func<A, B> fab, EitherAsync<L, Set<A>> fa) =>
            default(ApplEitherAsync<L, Set<A>, Set<B>>).Apply(
                default(MEitherAsync<L, Func<Set<A>, Set<B>>>).ReturnAsync(
                    Task.FromResult<Func<Set<A>, Set<B>>>((Set<A> a) => 
                        default(ApplSet< A, B>).Apply(
                            default(MSet< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, Set&lt;A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, Set<C>> ApplyT<L, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, Set<A>> fa, EitherAsync<L, Set<B>> fb) =>
            default(ApplEitherAsync<L, Set<A>, Set<B>, Set<C>>).Apply(
                default(MEitherAsync<L, Func<Set<A>, Func<Set<B>, Set<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Set<A>, Func<Set<B>, Set<C>>>>((Set<A> a) =>
                        (Set<B> b) =>
                            default(ApplSet< A, B, C>).Apply(
                                default(MSet< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Set<C>> SelectMany< A, B, C>(
            this Task<Set<A>> ma,
            Func<A, Task<Set<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Set<A>> Where< A>(this Task<Set<A>> ma, Func<A, bool> f)
        {
            Task<Set<A>> Do(Set<A> a) => default(MTask<Set<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Set<B>> Select< A, B>(this Task<Set<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<Set<B>>).ReturnAsync(_ => default(MSet<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this Task<Set<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this Task<Set<A>> ma) =>
            default(TransAsyncSync<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Set<B>> BindT< A, B>(this Task<Set<A>> ma, Func<A, Set<B>> f) =>
            default(TransAsyncSync<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>)
                .Bind<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Set<B>> MapT< A, B>(this Task<Set<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>)
                .Map<MTask<Set<B>>, Task<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this Task<Set<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this Task<Set<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this Task<Set<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this Task<Set<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this Task<Set<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<Set<A>>, Task<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Set<A>> FilterT< A>(this Task<Set<A>> ma, Func<A, bool> f)
        {
            Task<Set<A>> Do(Set<A> a) => default(MTask<Set<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Set<A>> PlusT<NUM,  A>(this Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Set<A>> SubtractT<NUM,  A>(this Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Set<A>> ProductT<NUM,  A>(this Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Set<A>> DivideT<NUM,  A>(this Task<Set<A>> x, Task<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Set<A>> AppendT<SEMI,  A>(this Task<Set<A>> x, Task<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this Task<Set<A>> x, Task<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this Task<Set<A>> x, Task<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Set<B>> ApplyT< A, B>(this Func<A, B> fab, Task<Set<A>> fa) =>
            default(ApplTask< Set<A>, Set<B>>).Apply(
                default(MTask< Func<Set<A>, Set<B>>>).ReturnAsync(
                    Task.FromResult<Func<Set<A>, Set<B>>>((Set<A> a) => 
                        default(ApplSet< A, B>).Apply(
                            default(MSet< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`Task&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, Task<Set<A>> fa, Task<Set<B>> fb) =>
            default(ApplTask< Set<A>, Set<B>, Set<C>>).Apply(
                default(MTask< Func<Set<A>, Func<Set<B>, Set<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Set<A>, Func<Set<B>, Set<C>>>>((Set<A> a) =>
                        (Set<B> b) =>
                            default(ApplSet< A, B, C>).Apply(
                                default(MSet< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Set<C>> SelectMany< A, B, C>(
            this TryAsync<Set<A>> ma,
            Func<A, TryAsync<Set<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Set<A>> Where< A>(this TryAsync<Set<A>> ma, Func<A, bool> f)
        {
            TryAsync<Set<A>> Do(Set<A> a) => default(MTryAsync<Set<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Set<B>> Select< A, B>(this TryAsync<Set<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<Set<B>>).ReturnAsync(_ => default(MSet<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryAsync<Set<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryAsync<Set<A>> ma) =>
            default(TransAsyncSync<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Set<B>> BindT< A, B>(this TryAsync<Set<A>> ma, Func<A, Set<B>> f) =>
            default(TransAsyncSync<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Bind<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Set<B>> MapT< A, B>(this TryAsync<Set<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Map<MTryAsync<Set<B>>, TryAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryAsync<Set<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryAsync<Set<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryAsync<Set<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<Set<A>>, TryAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Set<A>> FilterT< A>(this TryAsync<Set<A>> ma, Func<A, bool> f)
        {
            TryAsync<Set<A>> Do(Set<A> a) => default(MTryAsync<Set<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Set<A>> PlusT<NUM,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Set<A>> SubtractT<NUM,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Set<A>> ProductT<NUM,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Set<A>> DivideT<NUM,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Set<A>> AppendT<SEMI,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryAsync<Set<A>> x, TryAsync<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Set<B>> ApplyT< A, B>(this Func<A, B> fab, TryAsync<Set<A>> fa) =>
            default(ApplTryAsync< Set<A>, Set<B>>).Apply(
                default(MTryAsync< Func<Set<A>, Set<B>>>).ReturnAsync(
                    Task.FromResult<Func<Set<A>, Set<B>>>((Set<A> a) => 
                        default(ApplSet< A, B>).Apply(
                            default(MSet< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryAsync<Set<A>> fa, TryAsync<Set<B>> fb) =>
            default(ApplTryAsync< Set<A>, Set<B>, Set<C>>).Apply(
                default(MTryAsync< Func<Set<A>, Func<Set<B>, Set<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Set<A>, Func<Set<B>, Set<C>>>>((Set<A> a) =>
                        (Set<B> b) =>
                            default(ApplSet< A, B, C>).Apply(
                                default(MSet< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Set<C>> SelectMany< A, B, C>(
            this TryOptionAsync<Set<A>> ma,
            Func<A, TryOptionAsync<Set<B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MSet<C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> Where< A>(this TryOptionAsync<Set<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Set<A>> Do(Set<A> a) => default(MTryOptionAsync<Set<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> Select< A, B>(this TryOptionAsync<Set<A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<Set<B>>).ReturnAsync(_ => default(MSet<B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA,  A>(this TryOptionAsync<Set<A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;Set&lt;A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT< A>(this TryOptionAsync<Set<A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> BindT< A, B>(this TryOptionAsync<Set<A>> ma, Func<A, Set<B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Bind<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> MapT< A, B>(this TryOptionAsync<Set<A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Map<MTryOptionAsync<Set<B>>, TryOptionAsync<Set<B>>, MSet<B>, Set<B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S,  A>(this TryOptionAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S,  A>(this TryOptionAsync<Set<A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT< A>(this TryOptionAsync<Set<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT< A>(this TryOptionAsync<Set<A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;Set&lt;A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT< A>(this TryOptionAsync<Set<A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<Set<A>>, TryOptionAsync<Set<A>>, MSet<A>, Set<A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Set&lt;A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> FilterT< A>(this TryOptionAsync<Set<A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Set<A>> Do(Set<A> a) => default(MTryOptionAsync<Set<A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> PlusT<NUM,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> SubtractT<NUM,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> ProductT<NUM,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> DivideT<NUM,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Set<A>> AppendT<SEMI,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ,  A>(this TryOptionAsync<Set<A>> x, TryOptionAsync<Set<A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Set<B>> ApplyT< A, B>(this Func<A, B> fab, TryOptionAsync<Set<A>> fa) =>
            default(ApplTryOptionAsync< Set<A>, Set<B>>).Apply(
                default(MTryOptionAsync< Func<Set<A>, Set<B>>>).ReturnAsync(
                    Task.FromResult<Func<Set<A>, Set<B>>>((Set<A> a) => 
                        default(ApplSet< A, B>).Apply(
                            default(MSet< Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Set&lt;A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;Set&lt;A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Set&lt;B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Set<C>> ApplyT< A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Set<A>> fa, TryOptionAsync<Set<B>> fb) =>
            default(ApplTryOptionAsync< Set<A>, Set<B>, Set<C>>).Apply(
                default(MTryOptionAsync< Func<Set<A>, Func<Set<B>, Set<C>>>>).ReturnAsync(
                    Task.FromResult<Func<Set<A>, Func<Set<B>, Set<C>>>>((Set<A> a) =>
                        (Set<B> b) =>
                            default(ApplSet< A, B, C>).Apply(
                                default(MSet< Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
    /// <summary>
    /// Async monad transformer for Validation, provides functionality for working 
    /// with the inner value of the nested type.
    /// </summary>
    /// <typeparam name="A">The inner bound value type</typeparam>
    public static partial class ValidationT_AsyncSync_Extensions
    {
        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this OptionAsync<Validation<FAIL, A>> ma,
            Func<A, OptionAsync<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, A>> Where<FAIL, A>(this OptionAsync<Validation<FAIL, A>> ma, Func<A, bool> f)
        {
            OptionAsync<Validation<FAIL, A>> Do(Validation<FAIL, A> a) => default(MOptionAsync<Validation<FAIL, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, B>> Select<FAIL, A, B>(this OptionAsync<Validation<FAIL, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MOptionAsync<Validation<FAIL, B>>).ReturnAsync(_ => default(MValidation<FAIL, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, FAIL, A>(this OptionAsync<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MOptionAsync<Validation<FAIL, A>>, OptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<FAIL, A>(this OptionAsync<Validation<FAIL, A>> ma) =>
            default(TransAsyncSync<MOptionAsync<Validation<FAIL, A>>, OptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, B>> BindT<FAIL, A, B>(this OptionAsync<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            default(TransAsyncSync<MOptionAsync<Validation<FAIL, A>>, OptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Bind<MOptionAsync<Validation<FAIL, B>>, OptionAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, B>> MapT<FAIL, A, B>(this OptionAsync<Validation<FAIL, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MOptionAsync<Validation<FAIL, A>>, OptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Map<MOptionAsync<Validation<FAIL, B>>, OptionAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this OptionAsync<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Validation<FAIL, A>>, OptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this OptionAsync<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MOptionAsync<Validation<FAIL, A>>, OptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<FAIL, A>(this OptionAsync<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Validation<FAIL, A>>, OptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<FAIL, A>(this OptionAsync<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MOptionAsync<Validation<FAIL, A>>, OptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<FAIL, A>(this OptionAsync<Validation<FAIL, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MOptionAsync<Validation<FAIL, A>>, OptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, A>> FilterT<FAIL, A>(this OptionAsync<Validation<FAIL, A>> ma, Func<A, bool> f)
        {
            OptionAsync<Validation<FAIL, A>> Do(Validation<FAIL, A> a) => default(MOptionAsync<Validation<FAIL, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this OptionAsync<Validation<FAIL, A>> x, OptionAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this OptionAsync<Validation<FAIL, A>> x, OptionAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this OptionAsync<Validation<FAIL, A>> x, OptionAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this OptionAsync<Validation<FAIL, A>> x, OptionAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this OptionAsync<Validation<FAIL, A>> x, OptionAsync<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, FAIL, A>(this OptionAsync<Validation<FAIL, A>> x, OptionAsync<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, FAIL, A>(this OptionAsync<Validation<FAIL, A>> x, OptionAsync<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, OptionAsync<Validation<FAIL, A>> fa) =>
            default(ApplOptionAsync< Validation<FAIL, A>, Validation<FAIL, B>>).Apply(
                default(MOptionAsync< Func<Validation<FAIL, A>, Validation<FAIL, B>>>).ReturnAsync(
                    Task.FromResult<Func<Validation<FAIL, A>, Validation<FAIL, B>>>((Validation<FAIL, A> a) => 
                        default(ApplValidation<FAIL, A, B>).Apply(
                            default(MValidation<FAIL, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `OptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`OptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static OptionAsync<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, OptionAsync<Validation<FAIL, A>> fa, OptionAsync<Validation<FAIL, B>> fb) =>
            default(ApplOptionAsync< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>).Apply(
                default(MOptionAsync< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>).ReturnAsync(
                    Task.FromResult<Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>((Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            default(ApplValidation<FAIL, A, B, C>).Apply(
                                default(MValidation<FAIL, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, C>> SelectMany<L, FAIL, A, B, C>(
            this EitherAsync<L, Validation<FAIL, A>> ma,
            Func<A, EitherAsync<L, Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, A>> Where<L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Validation<FAIL, A>> Do(Validation<FAIL, A> a) => default(MEitherAsync<L, Validation<FAIL, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, B>> Select<L, FAIL, A, B>(this EitherAsync<L, Validation<FAIL, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MEitherAsync<L, Validation<FAIL, B>>).ReturnAsync(_ => default(MValidation<FAIL, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MEitherAsync<L, Validation<FAIL, A>>, EitherAsync<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> ma) =>
            default(TransAsyncSync<MEitherAsync<L, Validation<FAIL, A>>, EitherAsync<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, B>> BindT<L, FAIL, A, B>(this EitherAsync<L, Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            default(TransAsyncSync<MEitherAsync<L, Validation<FAIL, A>>, EitherAsync<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Bind<MEitherAsync<L, Validation<FAIL, B>>, EitherAsync<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, B>> MapT<L, FAIL, A, B>(this EitherAsync<L, Validation<FAIL, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MEitherAsync<L, Validation<FAIL, A>>, EitherAsync<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Map<MEitherAsync<L, Validation<FAIL, B>>, EitherAsync<L, Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Validation<FAIL, A>>, EitherAsync<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MEitherAsync<L, Validation<FAIL, A>>, EitherAsync<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Validation<FAIL, A>>, EitherAsync<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MEitherAsync<L, Validation<FAIL, A>>, EitherAsync<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MEitherAsync<L, Validation<FAIL, A>>, EitherAsync<L, Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, A>> FilterT<L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> ma, Func<A, bool> f)
        {
            EitherAsync<L, Validation<FAIL, A>> Do(Validation<FAIL, A> a) => default(MEitherAsync<L, Validation<FAIL, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, A>> PlusT<NUM, L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> x, EitherAsync<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, A>> SubtractT<NUM, L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> x, EitherAsync<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, A>> ProductT<NUM, L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> x, EitherAsync<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, A>> DivideT<NUM, L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> x, EitherAsync<L, Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, A>> AppendT<SEMI, L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> x, EitherAsync<L, Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> x, EitherAsync<L, Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, L, FAIL, A>(this EitherAsync<L, Validation<FAIL, A>> x, EitherAsync<L, Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, B>> ApplyT<L, FAIL, A, B>(this Func<A, B> fab, EitherAsync<L, Validation<FAIL, A>> fa) =>
            default(ApplEitherAsync<L, Validation<FAIL, A>, Validation<FAIL, B>>).Apply(
                default(MEitherAsync<L, Func<Validation<FAIL, A>, Validation<FAIL, B>>>).ReturnAsync(
                    Task.FromResult<Func<Validation<FAIL, A>, Validation<FAIL, B>>>((Validation<FAIL, A> a) => 
                        default(ApplValidation<FAIL, A, B>).Apply(
                            default(MValidation<FAIL, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `EitherAsync&lt;L, Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`EitherAsync&lt;L, Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static EitherAsync<L, Validation<FAIL, C>> ApplyT<L, FAIL, A, B, C>(this Func<A, B, C> fabc, EitherAsync<L, Validation<FAIL, A>> fa, EitherAsync<L, Validation<FAIL, B>> fb) =>
            default(ApplEitherAsync<L, Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>).Apply(
                default(MEitherAsync<L, Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>).ReturnAsync(
                    Task.FromResult<Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>((Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            default(ApplValidation<FAIL, A, B, C>).Apply(
                                default(MValidation<FAIL, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static Task<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this Task<Validation<FAIL, A>> ma,
            Func<A, Task<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Validation<FAIL, A>> Where<FAIL, A>(this Task<Validation<FAIL, A>> ma, Func<A, bool> f)
        {
            Task<Validation<FAIL, A>> Do(Validation<FAIL, A> a) => default(MTask<Validation<FAIL, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Validation<FAIL, B>> Select<FAIL, A, B>(this Task<Validation<FAIL, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTask<Validation<FAIL, B>>).ReturnAsync(_ => default(MValidation<FAIL, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `Task&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `Task&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, FAIL, A>(this Task<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTask<Validation<FAIL, A>>, Task<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `Task&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `Task&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<FAIL, A>(this Task<Validation<FAIL, A>> ma) =>
            default(TransAsyncSync<MTask<Validation<FAIL, A>>, Task<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Validation<FAIL, B>> BindT<FAIL, A, B>(this Task<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            default(TransAsyncSync<MTask<Validation<FAIL, A>>, Task<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Bind<MTask<Validation<FAIL, B>>, Task<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static Task<Validation<FAIL, B>> MapT<FAIL, A, B>(this Task<Validation<FAIL, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTask<Validation<FAIL, A>>, Task<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Map<MTask<Validation<FAIL, B>>, Task<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this Task<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Validation<FAIL, A>>, Task<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this Task<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTask<Validation<FAIL, A>>, Task<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<FAIL, A>(this Task<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Validation<FAIL, A>>, Task<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<FAIL, A>(this Task<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTask<Validation<FAIL, A>>, Task<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `Task&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<FAIL, A>(this Task<Validation<FAIL, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTask<Validation<FAIL, A>>, Task<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `Task&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static Task<Validation<FAIL, A>> FilterT<FAIL, A>(this Task<Validation<FAIL, A>> ma, Func<A, bool> f)
        {
            Task<Validation<FAIL, A>> Do(Validation<FAIL, A> a) => default(MTask<Validation<FAIL, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static Task<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this Task<Validation<FAIL, A>> x, Task<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static Task<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this Task<Validation<FAIL, A>> x, Task<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static Task<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this Task<Validation<FAIL, A>> x, Task<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static Task<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this Task<Validation<FAIL, A>> x, Task<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static Task<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this Task<Validation<FAIL, A>> x, Task<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, FAIL, A>(this Task<Validation<FAIL, A>> x, Task<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, FAIL, A>(this Task<Validation<FAIL, A>> x, Task<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static Task<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, Task<Validation<FAIL, A>> fa) =>
            default(ApplTask< Validation<FAIL, A>, Validation<FAIL, B>>).Apply(
                default(MTask< Func<Validation<FAIL, A>, Validation<FAIL, B>>>).ReturnAsync(
                    Task.FromResult<Func<Validation<FAIL, A>, Validation<FAIL, B>>>((Validation<FAIL, A> a) => 
                        default(ApplValidation<FAIL, A, B>).Apply(
                            default(MValidation<FAIL, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `Task&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `Task&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`Task&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static Task<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, Task<Validation<FAIL, A>> fa, Task<Validation<FAIL, B>> fb) =>
            default(ApplTask< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>).Apply(
                default(MTask< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>).ReturnAsync(
                    Task.FromResult<Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>((Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            default(ApplValidation<FAIL, A, B, C>).Apply(
                                default(MValidation<FAIL, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this TryAsync<Validation<FAIL, A>> ma,
            Func<A, TryAsync<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, A>> Where<FAIL, A>(this TryAsync<Validation<FAIL, A>> ma, Func<A, bool> f)
        {
            TryAsync<Validation<FAIL, A>> Do(Validation<FAIL, A> a) => default(MTryAsync<Validation<FAIL, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, B>> Select<FAIL, A, B>(this TryAsync<Validation<FAIL, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryAsync<Validation<FAIL, B>>).ReturnAsync(_ => default(MValidation<FAIL, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, FAIL, A>(this TryAsync<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryAsync<Validation<FAIL, A>>, TryAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<FAIL, A>(this TryAsync<Validation<FAIL, A>> ma) =>
            default(TransAsyncSync<MTryAsync<Validation<FAIL, A>>, TryAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, B>> BindT<FAIL, A, B>(this TryAsync<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            default(TransAsyncSync<MTryAsync<Validation<FAIL, A>>, TryAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Bind<MTryAsync<Validation<FAIL, B>>, TryAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, B>> MapT<FAIL, A, B>(this TryAsync<Validation<FAIL, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryAsync<Validation<FAIL, A>>, TryAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Map<MTryAsync<Validation<FAIL, B>>, TryAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this TryAsync<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Validation<FAIL, A>>, TryAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this TryAsync<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryAsync<Validation<FAIL, A>>, TryAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<FAIL, A>(this TryAsync<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Validation<FAIL, A>>, TryAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<FAIL, A>(this TryAsync<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryAsync<Validation<FAIL, A>>, TryAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<FAIL, A>(this TryAsync<Validation<FAIL, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryAsync<Validation<FAIL, A>>, TryAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, A>> FilterT<FAIL, A>(this TryAsync<Validation<FAIL, A>> ma, Func<A, bool> f)
        {
            TryAsync<Validation<FAIL, A>> Do(Validation<FAIL, A> a) => default(MTryAsync<Validation<FAIL, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this TryAsync<Validation<FAIL, A>> x, TryAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this TryAsync<Validation<FAIL, A>> x, TryAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this TryAsync<Validation<FAIL, A>> x, TryAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this TryAsync<Validation<FAIL, A>> x, TryAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this TryAsync<Validation<FAIL, A>> x, TryAsync<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, FAIL, A>(this TryAsync<Validation<FAIL, A>> x, TryAsync<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, FAIL, A>(this TryAsync<Validation<FAIL, A>> x, TryAsync<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, TryAsync<Validation<FAIL, A>> fa) =>
            default(ApplTryAsync< Validation<FAIL, A>, Validation<FAIL, B>>).Apply(
                default(MTryAsync< Func<Validation<FAIL, A>, Validation<FAIL, B>>>).ReturnAsync(
                    Task.FromResult<Func<Validation<FAIL, A>, Validation<FAIL, B>>>((Validation<FAIL, A> a) => 
                        default(ApplValidation<FAIL, A, B>).Apply(
                            default(MValidation<FAIL, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`TryAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryAsync<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, TryAsync<Validation<FAIL, A>> fa, TryAsync<Validation<FAIL, B>> fb) =>
            default(ApplTryAsync< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>).Apply(
                default(MTryAsync< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>).ReturnAsync(
                    Task.FromResult<Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>((Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            default(ApplValidation<FAIL, A, B, C>).Apply(
                                default(MValidation<FAIL, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

        /// <summary>
        /// Monadic bind and project operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Intermediate inner bound value type</typeparam>
        /// <typeparam name="C">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="bind">The bind function to apply</param>
        /// <param name="project">The projection function to apply after the bind</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, C&gt;&gt;` which is the result of performing bind then project</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, C>> SelectMany<FAIL, A, B, C>(
            this TryOptionAsync<Validation<FAIL, A>> ma,
            Func<A, TryOptionAsync<Validation<FAIL, B>>> bind,
            Func<A, B, C> project) =>
            ma.BindT(a =>
                bind(a).BindT(b =>
                    default(MValidation<FAIL, C>).Return(project(a, b))));

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// `true` then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, A>> Where<FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Validation<FAIL, A>> Do(Validation<FAIL, A> a) => default(MTryOptionAsync<Validation<FAIL, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, B>> Select<FAIL, A, B>(this TryOptionAsync<Validation<FAIL, A>> ma, Func<A, B> f) =>
            ma.BindT(a => default(MTryOptionAsync<Validation<FAIL, B>>).ReturnAsync(_ => default(MValidation<FAIL, B>).Return(f(a)).AsTask()));

        /// <summary>
        /// Finds total of all the `Num<A>`s in `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the sum operation on</param>
        /// <returns>Total of all `Num<A>`s in `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<A> SumT<NumA, FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> ma)
            where NumA : struct, Num<A> =>
                default(TransAsyncSync<MTryOptionAsync<Validation<FAIL, A>>, TryOptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, NumA, A>).Sum(ma);

        /// <summary>
        /// Finds the number of bound values in the `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the count operation on</param>
        /// <returns>Number of `A`s in `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</returns>
        [Pure]
        public static Task<int> CountT<FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> ma) =>
            default(TransAsyncSync<MTryOptionAsync<Validation<FAIL, A>>, TryOptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>).Count(ma);

        /// <summary>
        /// Monadic bind operation
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The bind function to apply</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, B>> BindT<FAIL, A, B>(this TryOptionAsync<Validation<FAIL, A>> ma, Func<A, Validation<FAIL, B>> f) =>
            default(TransAsyncSync<MTryOptionAsync<Validation<FAIL, A>>, TryOptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Bind<MTryOptionAsync<Validation<FAIL, B>>, TryOptionAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Functor map operation.  This maps the bound value(s) of the nested monads
        /// using the provided function `f`.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The mapping function to apply</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `f(a)`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, B>> MapT<FAIL, A, B>(this TryOptionAsync<Validation<FAIL, A>> ma, Func<A, B> f) =>
            default(TransAsyncSync<MTryOptionAsync<Validation<FAIL, A>>, TryOptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Map<MTryOptionAsync<Validation<FAIL, B>>, TryOptionAsync<Validation<FAIL, B>>, MValidation<FAIL, B>, Validation<FAIL, B>, B>(ma, f);

        /// <summary>
        /// Create an aggregate value by traversing the bound value(s) of the nested
        /// monadic type, whilst applying the aggregate state and bound value to `f` to
        /// produce the new aggregate state (which is then returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldT<S, FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Validation<FAIL, A>>, TryOptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, state, f);

        /// <summary>
        /// Create an aggregate value by traversing (in the opposite direction to `Fold`) 
        /// the bound value(s) of the nested monadic type, whilst applying the aggregate 
        /// state and bound value to `f` to produce the new aggregate state (which is then 
        /// returned).
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="S">Aggregate state type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The folding function to apply</param>
        /// <returns>The new aggregate state (which is then returned)</returns>
        [Pure]
        public static Task<S> FoldBackT<S, FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> ma, S state, Func<S, A, S> f) =>
            default(TransAsyncSync<MTryOptionAsync<Validation<FAIL, A>>, TryOptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .FoldBack(ma, state, f);

        /// <summary>
        /// Returns true if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if any of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then false is returned.</returns>
        [Pure]
        public static Task<bool> ExistsT<FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Validation<FAIL, A>>, TryOptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, false, (s, x) => s || f(x));

        /// <summary>
        /// Returns true if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>True if all of the bound value(s) return true when applied to the 
        /// predicate `f`.  If there are no bound values then true is returned.</returns>
        [Pure]
        public static Task<bool> ForAllT<FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> ma, Func<A, bool> f) =>
            default(TransAsyncSync<MTryOptionAsync<Validation<FAIL, A>>, TryOptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, true, (s, x) => s && f(x));

        /// <summary>
        /// Side-effecting operation to iterate all of the bound value(s) in `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The action that contains the side-effects</param>
        public static Task<Unit> IterT<FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> ma, Action<A> f) =>
            default(TransAsyncSync<MTryOptionAsync<Validation<FAIL, A>>, TryOptionAsync<Validation<FAIL, A>>, MValidation<FAIL, A>, Validation<FAIL, A>, A>)
                .Fold(ma, unit, (s, x) => { f(x); return unit; });

        /// <summary>
        /// Filter operation.  Applies the bound value to the predicate `f`. If
        /// true then that value is retained, else filtered out.
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <param name="ma">The `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` to perform the operation on</param>
        /// <param name="f">The predicate function</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` with the predicate `f(a)` applied</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, A>> FilterT<FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> ma, Func<A, bool> f)
        {
            TryOptionAsync<Validation<FAIL, A>> Do(Validation<FAIL, A> a) => default(MTryOptionAsync<Validation<FAIL, A>>).ReturnAsync(_ => a.Filter(f).AsTask());
            return ma.Bind(Do);
        }

        /// <summary>
        /// Adds the two inner `Num<A>` types together
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x + y</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, A>> PlusT<NUM, FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> x, TryOptionAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Plus, x, y);

        /// <summary>
        /// Finds the difference between two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing x - y</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, A>> SubtractT<NUM, FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> x, TryOptionAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Subtract, x, y);

        /// <summary>
        /// Finds the product of two inner `Num<A>` types
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x * y`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, A>> ProductT<NUM, FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> x, TryOptionAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Product, x, y);

        /// <summary>
        /// Divides `x` by `y`, which are both `Num<A>`s
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="NUM">`Num<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x / y`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, A>> DivideT<NUM, FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> x, TryOptionAsync<Validation<FAIL, A>> y) where NUM : struct, Num<A> =>
            ApplyT(default(NUM).Divide, x, y);

        /// <summary>
        /// Semigroup append operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="SEMI">`Semigroup<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x ++ y`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, A>> AppendT<SEMI, FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> x, TryOptionAsync<Validation<FAIL, A>> y) where SEMI : struct, Semigroup<A> =>
            ApplyT(default(SEMI).Append, x, y);

        /// <summary>
        /// `Ord` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="ORD">`Ord<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>If `x` is less than `y`: `-1`.  If `x` is greater than `y`: `+1`.  If `x` is equal to `y`: `0`</returns>
        [Pure]
        public static Task<int> CompareT<ORD, FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> x, TryOptionAsync<Validation<FAIL, A>> y) where ORD : struct, Ord<A> =>
            ApplyT(default(ORD).Compare, x, y).FoldT(0,(_, v) => v);

        /// <summary>
        /// `Eq` compare operation on the inner bound values
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="EQ">`Eq<A>` class instance</typeparam>
        /// <param name="x">The left hand side of the operation</param>
        /// <param name="y">The right hand side of the operation</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;` which is the result of performing `x == y`</returns>
        [Pure]
        public static Task<bool> EqualsT<EQ, FAIL, A>(this TryOptionAsync<Validation<FAIL, A>> x, TryOptionAsync<Validation<FAIL, A>> y) where EQ : struct, Eq<A> =>
            ApplyT(default(EQ).Equals, x, y).FoldT(true,(s, v) => s && v);

        /// <summary>
        /// Apply `fa` to `fab`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fab">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fab(fa)`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, B>> ApplyT<FAIL, A, B>(this Func<A, B> fab, TryOptionAsync<Validation<FAIL, A>> fa) =>
            default(ApplTryOptionAsync< Validation<FAIL, A>, Validation<FAIL, B>>).Apply(
                default(MTryOptionAsync< Func<Validation<FAIL, A>, Validation<FAIL, B>>>).ReturnAsync(
                    Task.FromResult<Func<Validation<FAIL, A>, Validation<FAIL, B>>>((Validation<FAIL, A> a) => 
                        default(ApplValidation<FAIL, A, B>).Apply(
                            default(MValidation<FAIL, Func<A, B>>).Return(fab), 
                            a))),
                fa);

        /// <summary>
        /// Apply `fa` and `fb` to `fabc`
        /// </summary>
        /// <typeparam name="A">Inner bound value type</typeparam>
        /// <typeparam name="B">Resulting bound value type</typeparam>
        /// <param name="fabc">Functor</param>
        /// <param name="fa">Monad of `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <param name="fb">Monad of `TryOptionAsync&lt;Validation&lt;FAIL, A&gt;&gt;`</param>
        /// <returns>`TryOptionAsync&lt;Validation&lt;FAIL, B&gt;&gt;` which is the result of performing `fabc(fa, fb)`</returns>
        [Pure]
        public static TryOptionAsync<Validation<FAIL, C>> ApplyT<FAIL, A, B, C>(this Func<A, B, C> fabc, TryOptionAsync<Validation<FAIL, A>> fa, TryOptionAsync<Validation<FAIL, B>> fb) =>
            default(ApplTryOptionAsync< Validation<FAIL, A>, Validation<FAIL, B>, Validation<FAIL, C>>).Apply(
                default(MTryOptionAsync< Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>).ReturnAsync(
                    Task.FromResult<Func<Validation<FAIL, A>, Func<Validation<FAIL, B>, Validation<FAIL, C>>>>((Validation<FAIL, A> a) =>
                        (Validation<FAIL, B> b) =>
                            default(ApplValidation<FAIL, A, B, C>).Apply(
                                default(MValidation<FAIL, Func<A, Func<B, C>>>).Return(curry(fabc)), a, b))), fa, fb);

    }
}
